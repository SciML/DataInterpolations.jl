var documenterSearchIndex = {"docs":
[{"location":"symbolics/#Using-DataInterpolations.jl-with-Symbolics.jl-and-ModelingToolkit.jl","page":"Using with Symbolics/ModelingToolkit","title":"Using DataInterpolations.jl with Symbolics.jl and ModelingToolkit.jl","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"All interpolation methods can be integrated with Symbolics.jl and ModelingToolkit.jl seamlessly.","category":"page"},{"location":"symbolics/#Using-with-Symbolics.jl","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics.jl","text":"","category":"section"},{"location":"symbolics/#Expressions","page":"Using with Symbolics/ModelingToolkit","title":"Expressions","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"using DataInterpolations, Symbolics\nusing Test\n\nu = [0.0, 1.5, 0.0]\nt = [0.0, 0.5, 1.0]\nA = LinearInterpolation(u, t)\n\n@variables τ\n\n# Simple Expression\nex = cos(τ) * A(τ)\n@test substitute(ex, Dict(τ => 0.5)) == cos(0.5) * A(0.5) # true","category":"page"},{"location":"symbolics/#Symbolic-Derivatives","page":"Using with Symbolics/ModelingToolkit","title":"Symbolic Derivatives","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"D = Differential(τ)\n\nex1 = A(τ)\n\n# Derivative of interpolation\nex2 = expand_derivatives(D(ex1))\n\n@test substitute(ex2, Dict(τ => 0.5)) == DataInterpolations.derivative(A, 0.5) # true\n\n# Higher Order Derivatives\nex3 = expand_derivatives(D(D(A(τ))))\n\n@test substitute(ex3, Dict(τ => 0.5)) == DataInterpolations.derivative(A, 0.5, 2) # true","category":"page"},{"location":"symbolics/#Using-with-ModelingToolkit.jl","page":"Using with Symbolics/ModelingToolkit","title":"Using with ModelingToolkit.jl","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"We recommend using the ModelingToolkitStandardLibrary Interpolation Blocks in order to use DataInterpolations.jl in MTK models.","category":"page"},{"location":"arclength_interpolation/#Smooth-arc-length-interpolation","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"","category":"section"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"Arc length interpolation is interpolation between points using a curve that is parameterized by arc length. That is: the curve parameterization has unit speed everywhere, and so the parameter t at each point on the curve is equal to the total distance traveled from the beginning of the curve. In this context, by 'smooth' we mean that the curve is continuously differentiable.","category":"page"},{"location":"arclength_interpolation/#Usage","page":"Smooth arc length interpolation","title":"Usage","text":"","category":"section"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"DataInteprolations.jl offers an arc length interpolation method that approximates an existing non arc length interpolation by circle and line segments. This can be done by providing an interpolation object (the shape interpolation):","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"using DataInterpolations\nusing Plots\nusing Random\n\nRandom.seed!(2)\n\n# Example from interpolation object\nu = cumsum([rand(3) for _ in 1:10])\nt = 1:10\nA_shape = QuadraticSpline(u, t)\nA = SmoothArcLengthInterpolation(A_shape; m = 10)\n\nfunction plot_itp(itp)\n    t_eval = range(itp.t[1], itp.t[end]; length = 1000)\n    u_eval = zeros(3, 1000)\n    itp(u_eval, t_eval)\n\n    plot(eachrow(u_eval)...; label = \"SmoothArcLengthInterpolation\")\n    scatter!(eachrow(u_eval[:, 1:50:end])...; label = \"Equidistant points on the curve\")\n    scatter!(eachrow(hcat(A.shape_itp.u...))...; label = \"Original data\")\nend\n\nplot_itp(A)","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"Here m determines how fine the approximation is. It is also possible to just provide the data points, optionally providing t and a preferred interpolation type which determines the shape of the curve.","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"using LinearAlgebra\n\n# Example from only u\nA = SmoothArcLengthInterpolation(hcat(u...))\n@show typeof(A.shape_itp)\nplot_itp(A)","category":"page"},{"location":"arclength_interpolation/#Docstrings","page":"Smooth arc length interpolation","title":"Docstrings","text":"","category":"section"},{"location":"arclength_interpolation/#DataInterpolations.SmoothArcLengthInterpolation-Union{Tuple{AbstractMatrix{U}}, Tuple{U}} where U","page":"Smooth arc length interpolation","title":"DataInterpolations.SmoothArcLengthInterpolation","text":" SmoothArcLengthInterpolation(\n    u::AbstractMatrix{U};\n    t::Union{AbstractVector, Nothing} = nothing,\n    interpolation_type::Type{<:AbstractInterpolation} = QuadraticSpline,\n    kwargs...) where {U}\n\nInterpolate in a C¹ smooth way through the data with unit speed by approximating an interpolation (the shape interpolation) with line segments and circle segments.\n\nArguments\n\nu: The data to be interpolated in matrix form; (ndim, ndata).\n\nNOTE: With this method it is not possible to pass keyword arguments to the constructor of the shape interpolation. If you want to do this, construct the shape interpolation yourself and use the SmoothArcLengthInterpolation(shape_itp::AbstractInterpolation; kwargs...) method.\n\nKeyword Arguments\n\nt: The time points of the shape interpolation. By default given by the cumulative sum of the Euclidean distances between the points u.\ninterpolation_type: The type of the shape interpolation. Defaults to QuadraticSpline. Note that for the SmoothArcLengthInterpolation to be C¹ smooth, the interpolation_type must be C¹ smooth as well.\nm: The number of points at which the shape interpolation is evaluated in each interval between time points. The SmoothArcLengthInterpolation converges to the shape interpolation (in shape) as m → ∞.\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"method"},{"location":"arclength_interpolation/#DataInterpolations.SmoothArcLengthInterpolation-Tuple{DataInterpolations.AbstractInterpolation}","page":"Smooth arc length interpolation","title":"DataInterpolations.SmoothArcLengthInterpolation","text":"function SmoothArcLengthInterpolation(\n        shape_itp::AbstractInterpolation;\n        m::Integer = 2,\n        kwargs...)\n\nApproximate the shape_itp with a C¹ unit speed interpolation using line segments and circle segments.\n\nArguments\n\nshape_itp: The interpolation to be approximated. Note that for the SmoothArcLengthInterpolation to be C¹ smooth, the shape_itp must be C¹ smooth as well.\n\nKeyword Arguments\n\nm: The number of points at which the shape interpolation is evaluated in each interval between time points. The SmoothArcLengthInterpolation converges to the shape interpolation (in shape) as m → ∞.\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"method"},{"location":"arclength_interpolation/#DataInterpolations.SmoothArcLengthInterpolation-Tuple{AbstractMatrix, AbstractMatrix}","page":"Smooth arc length interpolation","title":"DataInterpolations.SmoothArcLengthInterpolation","text":"function SmoothArcLengthInterpolation(\n    u::AbstractMatrix,\n    d::AbstractMatrix\n    [, make_intersections::Val{<:Bool}];\n    shape_itp::Union{AbstractInterpolation, Nothing} = nothing,\n    extrapolation::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None,\n    cache_parameters::Bool = false,\n    assume_linear_t = 1e-2,\n    in_place::Bool = true)\n\nMake a C¹ smooth unit speed interpolation through the given data with the given tangents using line segments and circle segments.\n\nArguments\n\nu: The data to be interpolated in matrix form; (ndim, ndata).\nd: The tangents to the curve in the points u.\nmake_intersections: Whether additional (point, tangent) pairs have to be added in between the provided data to ensure that the consecutive (tangent) lines intersect. Defaults to Val(true).\n\nKeyword Arguments\n\nshape_itp: The interpolation that is being approximated, if one exists. Note that this interpolation is not being used; it is just passed along to keep track of where the shape of the SmoothArcLengthInterpolation originated.\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"method"},{"location":"arclength_interpolation/#Method-derivation","page":"Smooth arc length interpolation","title":"Method derivation","text":"","category":"section"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"Say we have an ordered set of points u_1 ldots u_n in mathbbR^N and we want to make a lightweight C^1 smooth interpolation by arc-length tildegamma 0T rightarrow mathbbR^N through these points. The first part is easy, just pick your favorite established interpolation method that achieves C^1 smoothness. The arc-length part however turns out to be quite nasty. Here I propose a method that is quite general and cheap to compute.","category":"page"},{"location":"arclength_interpolation/#The-2-dimensional-case","page":"Smooth arc length interpolation","title":"The 2-dimensional case","text":"","category":"section"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"2 is the smallest number of dimensions in which the posed problem is non-trivial. Say we use an established (non arc-length) interpolation method for our set of points to obtain the C^1 curve","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    gamma  0 T rightarrow mathbbR^2","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"for which","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    gamma(t_i) = u_i quad i = 1 ldots n","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"given a suitable set of 'time' values","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    0 = t_1  t_2  ldots  t_n = T","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"for instance","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    t_i = sum_k=1^i-1 u_k+1 - u_k_2","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"We now want to approximate gamma piecewise with sections that are trivially parameterizable by arc-length, namely line segments and circle segments. To do this, we fix some m in mathbbN and define a refined set of time points left(tildet_jright)_j=1^m(n-1) + 1 given by","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildet_m(k-1) + l = t_k + fraclm + 1(t_k+1 - t_k) quad k = 1 ldots n-1  l = 1 ldots m","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"In these refined time points we evaluate gamma and its normalized derivative:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j = gammaleft(tildet_jright)  tilded_j = fracdotgammaleft(tildet_jright)dotgammaleft(tildet_jright)_2 qquad j = 1 ldots m(n-1) + 1","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"As a first step to create the interpolation by arc length tildegamma, we make a piecewise linear curve which is tangent to gamma in tildeu_j for each line segment, where we denote the intersection of consecutive tangent lines by tildeu_j textint:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    beginalign*\n    tildeu_j textint = tildeu_j + fraclangletildeu_j+1-tildeu_j tilded_jrangle - langletilded_j tilded_j+1rangle langletildeu_j+1-tildeu_j tilded_j+1rangle1 - langletilded_j tilded_j+1rangle^2tilded_j \n    = tildeu_j+1 + fraclangletilded_j tilded_j+1ranglelangletildeu_j+1-tildeu_j tilded_jrangle - langletildeu_j+1-tildeu_j tilded_j+1rangle1 - langletilded_j tilded_j+1rangle^2tilded_j+1\n    endalign*","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"As expected this doesn't work for langletilded_j tilded_j+1rangle^2 = 1, which means that the consecutive tangent lines are parallel. In fact, in the above equation we want the coefficient of tilded_j to be positive and the coefficient of tilded_j+1 to be negative, to ensure that tildeu_j textint lies properly in between tildeu_j and tildeu_j+1.","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"plot_tangent_curve() # hide","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"As a last step to obtain our curve by arc length tildegamma we want to get rid of the kinks in the tangent curve. We do this by replacing sections of the tangent curve by circle arcs. For each tildeu_j textint we compute the shortest distance to the neighboring evaluation points on gamma:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    delta_j = minleft\n        tildeu_j - tildeu_j textint_2 \n        tildeu_j + 1 - tildeu_j textint_2\n    right","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"From this we compute 2 points that are on the tangent curve and equidistant from tildeu_j  + frac12:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textstart = tildeu_j textint - delta_j tilded_j ","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textend = tildeu_j textint + delta_j tilded_j+1","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"Note that by this definition","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textstart = tildeu_j quad vee quad tildeu_j textend = tildeu_j  + 1","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"Now we can define a circle arc from tildeu_j textstart to tildeu_j textend given the center","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    c_j = tildeu_j textint + delta_jfractilded_j+1 - tilded_j1 - langletilded_jtilded_j+1rangle","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"and radius","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    R_j = delta_jsqrtfrac1 + langletilded_jtilded_j+1rangle1 - langletilded_jtilded_j+1rangle","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"We obtain the circle arc","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    c_j + cosleft(fractR_jright)v_j 1 + sinleft(fractR_jright)v_j 2 quad t in 0 Delta t_j textarc","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"where","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    v_j 1 = -delta_j fractilded_j+1 - langletilded_jtilded_j+1rangletilded_j1 - langletilded_jtilded_j+1rangle\n    quad\n    v_j 2 = R_j tilded_j","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"By this definition v_j 1_2 = v_j 2_2 = R_j and langle v_j 1 v_j 2rangle = 0. Furthermore:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    Delta t_j textarc = R_jtheta_j max= 2R_j arctanleft(fracdelta_jR_jright)","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"plot_arc_construction()[1] # hide","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"p # hide","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"That's pretty neat, but this method does not directly generalize to higher dimensional spaces. That is because in general the intersection points tildeu_j textint of the tangent lines do not exist.","category":"page"},{"location":"arclength_interpolation/#The-higher-dimensional-case","page":"Smooth arc length interpolation","title":"The higher dimensional case","text":"","category":"section"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"Let's try to generalize the method above. The goal is to find a point tildeu_j + frac12 and unit direction tilded_j + frac12 to add to the tangent curve between tildeu_j and tildeu_j+1 such that:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"the tangent line intersections tildeu_j textint left tildeu_j textint right exist. This means that the new line is fixed by these 2 points;\nconstructing tildegamma including this point gives gives an identical result to constructing tildegamma excluding this point if the tangent line intersection already existed. The latter implies that tildeu_j + frac12 and tilded_j + frac12 yield a tangent line to the constructed circle arc.","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"Let's assume the tangent line intersection exists, and we define","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textint left = tildeu_j textint - delta_j^* tilded_j","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textint right = tildeu_j textint + delta_j^* tilded_j+1","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"It turns out that if we then let","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"delta^*_j = delta_j frac2 - sqrt2 + 2 langletilded_j tilded_j+1rangle1 - langletilded_j tilded_j+1rangle","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"The line between tildeu_ textint left and $ \\tilde{u}_{, \\text{int right}}$ touches the circle arc as constructed before. It follows that","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j + frac12 = frac12lefttildeu_j textint left + tildeu_j textint rightright\n    qquad\n    tilded_j + frac12 = fractildeu_j textint right - tildeu_j textint lefttildeu_j textint right - tildeu_j textint left_2","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"p # hide","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"If we generalize the definition of tildeu_j textint then we can compute  tildeu_j + frac12 and tilded_j + frac12 as above. Something we can always compute are the points on the tangent lines which are closest together, given by:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    argmin_s t in mathbbR tildeu_j+1 + stilded_j+1 - (tildeu_j + ttilded_j)_2","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"This yields","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textclose left = tildeu_j + fraclangletildeu_j+1-tildeu_j tilded_jrangle - langletilded_j tilded_j+1rangle langletildeu_j+1-tildeu_j tilded_j+1rangle1 - langletilded_j tilded_j+1rangle^2tilded_j","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textclose right = tildeu_j+1 + fraclangletilded_j tilded_j+1ranglelangletildeu_j+1-tildeu_j tilded_jrangle - langletildeu_j+1-tildeu_j tilded_j+1rangle1 - langletilded_j tilded_j+1rangle^2tilded_j+1","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"This is the same as the two expressions for tildeu_j textint from before, except now these expressions aren't necessarily equal. We define tildeu_j textint as the average of these expressions:","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textint = fractildeu_j textclose left + tildeu_j textclose right2","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"From this delta_j and delta_j^* follow, and","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textint left = tildeu_j textclose left - delta_j^* tilded_j","category":"page"},{"location":"arclength_interpolation/","page":"Smooth arc length interpolation","title":"Smooth arc length interpolation","text":"    tildeu_j textint right = tildeu_j textclose right + delta_j^* tilded_j+1","category":"page"},{"location":"extrapolation_methods/#Extrapolation-methods","page":"Extrapolation methods","title":"Extrapolation methods","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"We will use the following interpolation to demonstrate the various extrapolation methods.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"using DataInterpolations, Plots\n\nu = [0.86, 0.65, 0.44, 0.76, 0.73]\nt = [0.0022, 0.68, 1.41, 2.22, 2.46]\nt_eval_left = range(-1, first(t), length = 25)\nt_eval_right = range(last(t), 3.5, length = 25)\nA = QuadraticSpline(u, t)\nplot(A)","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"Extrapolation behavior can be set left and right of the data simultaneously with the extrapolation keyword, or left and right separately with the extrapolation_left and extrapolation_right keywords respectively.","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.None","page":"Extrapolation methods","title":"ExtrapolationType.None","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type will throw an error when the input t is beyond the data in the specified direction.","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Constant","page":"Extrapolation methods","title":"ExtrapolationType.Constant","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type extends the interpolation with the boundary values of the data u.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Constant)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation left\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation right\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Linear","page":"Extrapolation methods","title":"ExtrapolationType.Linear","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type extends the interpolation with a linear continuation of the interpolation, making it C^1 smooth at the data boundaries.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Linear)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation left\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation right\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Extension","page":"Extrapolation methods","title":"ExtrapolationType.Extension","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type extends the interpolation with a continuation of the expression for the interpolation at the boundary intervals for maximum smoothness.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Extension)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation down\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation up\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Periodic","page":"Extrapolation methods","title":"ExtrapolationType.Periodic","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"this extrapolation type extends the interpolation such that A(t + T) == A(t) for all t, where the period is given by T = last(A.t) - first(A.t).","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"T = last(A.t) - first(A.t)\nt_eval_left = range(first(t) - 2T, first(t), length = 100)\nt_eval_right = range(last(t), last(t) + 2T, length = 100)\nA = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Periodic)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation down\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation up\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Reflective","page":"Extrapolation methods","title":"ExtrapolationType.Reflective","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"this extrapolation type extends the interpolation such that A(t_ + t) == A(t_ - t) for all t_, t such that (t_ - first(A.t)) % T == 0 and 0 < t < T, where T = last(A.t) - first(A.t).","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Reflective)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation down\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation up\")","category":"page"},{"location":"extrapolation_methods/#Mixed-extrapolation","page":"Extrapolation methods","title":"Mixed extrapolation","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"You can also have different extrapolation types left and right of the data.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation_left = ExtrapolationType.Reflective,\n    extrapolation_right = ExtrapolationType.Periodic)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation left\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation right\")","category":"page"},{"location":"inverting_integrals/#Inverting-integrals","page":"Inverting Integrals","title":"Inverting integrals","text":"","category":"section"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"Solving implicit integral problems of the following form is supported:","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"beginequation\n    textfind t such that  int_t_1^t f(tau)textdtau = V ge 0\nendequation","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"where t_1 is given by first(A.t). This is supported for interpolations f that are strictly positive and of one of these types:","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"ConstantInterpolation\nLinearInterpolation","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"This is achieved by creating an 'integral inverse' interpolation object which can efficiently compute t for a given value of V, see the example below.","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"using Random #hide\nRandom.seed!(1234) # hide\nusing DataInterpolations\nusing Plots\n\n# Create LinearInterpolation object from the\nu = sqrt.(1:25) + (2.0 * rand(25) .- 1.0) / 3\nt = cumsum(rand(25))\nA = LinearInterpolation(u, t)\n\n# Create LinearInterpolationIntInv object\n# from the LinearInterpolation object\nA_intinv = DataInterpolations.invert_integral(A)\n\n# Get the t values up to and including the\n# solution to the integral problem\nV = 25.0\nt_ = A_intinv(V)\nts = t[t .<= t_]\npush!(ts, t_)\n\n# Plot results\nplot(A; label = \"Linear Interpolation\")\nplot!(ts, A.(ts), fillrange = 0.0, fillalpha = 0.75,\n    fc = :blues, lw = 0, label = \"Area of $V\")","category":"page"},{"location":"inverting_integrals/#Docstrings","page":"Inverting Integrals","title":"Docstrings","text":"","category":"section"},{"location":"inverting_integrals/#DataInterpolations.invert_integral","page":"Inverting Integrals","title":"DataInterpolations.invert_integral","text":"invert_integral(A::AbstractInterpolation)::AbstractIntegralInverseInterpolation\n\nCreates the inverted integral interpolation object from the given interpolation. Conditions:\n\nThe range of A must be strictly positive\nA.u must be a number type (on which an ordering is defined)\nThis is currently only supported for ConstantInterpolation and LinearInterpolation\n\nArguments\n\nA: interpolation object satisfying the above requirements\n\n\n\n\n\n","category":"function"},{"location":"inverting_integrals/#DataInterpolations.ConstantInterpolationIntInv","page":"Inverting Integrals","title":"DataInterpolations.ConstantInterpolationIntInv","text":"ConstantInterpolationIntInv(u, t, A)\n\nIt is the interpolation of the inverse of the integral of a ConstantInterpolation. Can be easily constructed with invert_integral(A::ConstantInterpolation{<:AbstractVector{<:Number}})\n\nArguments\n\nu : Given by A.t\nt : Given by A.I (the cumulative integral of A)\nA : The ConstantInterpolation object\n\n\n\n\n\n","category":"type"},{"location":"inverting_integrals/#DataInterpolations.LinearInterpolationIntInv","page":"Inverting Integrals","title":"DataInterpolations.LinearInterpolationIntInv","text":"LinearInterpolationIntInv(u, t, A)\n\nIt is the interpolation of the inverse of the integral of a LinearInterpolation. Can be easily constructed with invert_integral(A::LinearInterpolation{<:AbstractVector{<:Number}})\n\nArguments\n\nu : Given by A.t\nt : Given by A.I (the cumulative integral of A)\nA : The LinearInterpolation object\n\n\n\n\n\n","category":"type"},{"location":"interface/#Interface-for-using-the-Interpolations-object","page":"Interface","title":"Interface for using the Interpolations object","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"We will again use the same data as the previous tutorial to demonstrate how to use the Interpolations object for computing interpolated values at any time point, as well as derivatives and integrals.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"using DataInterpolations\n\n# Dependent variable\nu = [14.7, 11.51, 10.41, 14.95, 12.24, 11.22]\n\n# Independent variable\nt = [0.0, 62.25, 109.66, 162.66, 205.8, 252.3]","category":"page"},{"location":"interface/#Interpolated-values","page":"Interface","title":"Interpolated values","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All interpolation methods return an object from which we can compute the value of the dependent variable at any time point.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"We will use the CubicSpline method for demonstration, but the API is the same for all the methods. We can also pass the extrapolation = ExtrapolationType.Extension keyword if we want to allow the interpolation to go beyond the range of the timepoints in the positive t direction. The default value is extrapolation = ExtrapolationType.None. For more information on extrapolation see Extrapolation methods.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"A1 = CubicSpline(u, t)\n\n# For interpolation do, A(t)\nA1(100.0)\n\nA2 = CubicSpline(u, t; extrapolation = ExtrapolationType.Extension)\n\n# Extrapolation\nA2(300.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"note: Note\nThe values computed beyond the range of the time points provided during interpolation will not be reliable, as these methods only perform well within the range and the first/last piece polynomial fit is extrapolated on either side which might not reflect the true nature of the data.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The keyword cache_parameters = true can be passed to precalculate parameters at initialization, making evaluations cheaper to compute. This is not compatible with modifying u and t. The default cache_parameters = false does however not prevent allocation in every interpolation constructor call.","category":"page"},{"location":"interface/#Derivatives","page":"Interface","title":"Derivatives","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Derivatives of the interpolated curves can also be computed at any point for all the methods. Derivatives upto second order is supported where first order derivative is computed analytically and second order using ForwardDiff.jl. Order is passed as the third argument. It is 1 by default.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"We will continue with the above example, but the API is the same for all the methods. If the interpolation is defined with extrapolate=true, derivatives can also be extrapolated.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# derivative(A, t)\nDataInterpolations.derivative(A1, 1.0, 1)\nDataInterpolations.derivative(A1, 1.0, 2)\n\n# Extrapolation\nDataInterpolations.derivative(A2, 300.0)","category":"page"},{"location":"interface/#Integrals","page":"Interface","title":"Integrals","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Integrals of the interpolated curves can also be computed easily.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"note: Note\nIntegrals for LagrangeInterpolation, BSplineInterpolation, BSplineApprox, Curvefit will error as there are no simple analytical solutions available. Please use numerical methods instead, such as Integrals.jl.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"To compute the integrals from the start of time points provided during interpolation to any point, we can do:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# integral(A, t)\nDataInterpolations.integral(A1, 5.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"If we want to compute integrals between two points, we can do:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# integral(A, t1, t2)\nDataInterpolations.integral(A1, 1.0, 5.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Again, if the interpolation is defined with extrapolate=true, the integral can be computed beyond the range of the timepoints.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# integral(A, t1, t2)\nDataInterpolations.integral(A2, 200.0, 300.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"note: Note\nIf the times provided in the integral go beyond the range of the time points provided during interpolation, it uses extrapolation methods to compute the values, and hence the integral can be misrepsentative and might not reflect the true nature of the data.","category":"page"},{"location":"manual/#Methods","page":"Manual","title":"Methods","text":"","category":"section"},{"location":"manual/#DataInterpolations.LinearInterpolation","page":"Manual","title":"DataInterpolations.LinearInterpolation","text":"LinearInterpolation(u, t; extrapolation_left::ExtrapolationType.T = ExtrapolationType.None, \nextrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, \ncache_parameters = false)\n\nIt is the method of interpolating between the data points using a linear polynomial. For any point, two data points one each side are chosen and connected with a line. Extrapolation extends the last linear polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behavior for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.QuadraticInterpolation","page":"Manual","title":"DataInterpolations.QuadraticInterpolation","text":"QuadraticInterpolation(u, t, mode = :Forward; extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, \n    cache_parameters = false)\n\nIt is the method of interpolating between the data points using quadratic polynomials. For any point, three data points nearby are taken to fit a quadratic polynomial. Extrapolation extends the last quadratic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\nmode: :Forward or :Backward. If :Forward, two data points ahead of the point and one data point behind is taken for interpolation. If :Backward, two data points behind and one ahead is taken for interpolation.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.LagrangeInterpolation","page":"Manual","title":"DataInterpolations.LagrangeInterpolation","text":"LagrangeInterpolation(u, t, n = length(t) - 1; extrapolation::ExtrapolationType.T = ExtrapolationType.None, \nextrapolation_left::ExtrapolationType.T = ExtrapolationType.None, extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is the method of interpolation using Lagrange polynomials of (k-1)th order passing through all the data points where k is the number of data points.\n\nArguments\n\nu: data points.\nt: time points.\nn: order of the polynomial. Currently only (k-1)th order where k is the number of data points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.AkimaInterpolation","page":"Manual","title":"DataInterpolations.AkimaInterpolation","text":"AkimaInterpolation(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a spline interpolation built from cubic polynomials. It forms a continuously differentiable function. For more details, refer: https://en.wikipedia.org/wiki/Akima_spline. Extrapolation extends the last cubic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.ConstantInterpolation","page":"Manual","title":"DataInterpolations.ConstantInterpolation","text":"ConstantInterpolation(u, t; dir = :left, extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is the method of interpolating using a constant polynomial. For any point, two adjacent data points are found on either side (left and right). The value at that point depends on dir. If it is :left, then the value at the left point is chosen and if it is :right, the value at the right point is chosen. Extrapolation extends the last constant polynomial at the end points on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\ndir: indicates which value should be used for interpolation (:left or :right).\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.SmoothedConstantInterpolation","page":"Manual","title":"DataInterpolations.SmoothedConstantInterpolation","text":"SmoothedConstantInterpolation(u, t; d_max = Inf, extrapolate = false,\n    cache_parameters = false, assume_linear_t = 1e-2)\n\nIt is a method for interpolating constantly with forward fill, with smoothing around the value transitions to make the curve continuously differentiable while the integral never drifts far from the integral of constant interpolation. u[end] is ignored, except when using extrapolation types Constant or Extension.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nd_max: Around each time point tᵢ there is a continuously differentiable (quadratic) transition between uᵢ₋₁ and uᵢ, on the interval [tᵢ - d, tᵢ + d]. The distance d is determined as d = min((tᵢ - tᵢ₋₁)/2, (tᵢ₊₁ - tᵢ)/2, d_max).\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic (also made smooth at the boundaries) and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behavior for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.QuadraticSpline","page":"Manual","title":"DataInterpolations.QuadraticSpline","text":"QuadraticSpline(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a spline interpolation using piecewise quadratic polynomials between each pair of data points. Its first derivative is also continuous. Extrapolation extends the last quadratic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.CubicSpline","page":"Manual","title":"DataInterpolations.CubicSpline","text":"CubicSpline(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a spline interpolation using piecewise cubic polynomials between each pair of data points. Its first and second derivative is also continuous. Second derivative on both ends are zero, which are also called \"natural\" boundary conditions. Extrapolation extends the last cubic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.BSplineInterpolation","page":"Manual","title":"DataInterpolations.BSplineInterpolation","text":"BSplineInterpolation(u, t, d, pVecType, knotVecType; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a curve defined by the linear combination of n basis functions of degree d where n is the number of data points. For more information, refer https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve.html. Extrapolation is a constant polynomial of the end points on each side.\n\nArguments\n\nu: data points.\nt: time points.\nd: degree of the piecewise polynomial.\npVecType: symbol to parameters vector, :Uniform for uniform spaced parameters and :ArcLen for parameters generated by chord length method.\nknotVecType: symbol to knot vector, :Uniform for uniform knot vector, :Average for average spaced knot vector.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nassume_linear_t: boolean value to specify a faster index lookup behavior for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.BSplineApprox","page":"Manual","title":"DataInterpolations.BSplineApprox","text":"BSplineApprox(u, t, d, h, pVecType, knotVecType; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a regression based B-spline. The argument choices are the same as the BSplineInterpolation, with the additional parameter h < length(t) which is the number of control points to use, with smaller h indicating more smoothing. For more information, refer http://www.cad.zju.edu.cn/home/zhx/GM/009/00-bsia.pdf. Extrapolation is a constant polynomial of the end points on each side.\n\nArguments\n\nu: data points.\nt: time points.\nd: degree of the piecewise polynomial.\nh: number of control points to use.\npVecType: symbol to parameters vector, :Uniform for uniform spaced parameters and :ArcLen for parameters generated by chord length method.\nknotVecType: symbol to knot vector, :Uniform for uniform knot vector, :Average for average spaced knot vector.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.CubicHermiteSpline","page":"Manual","title":"DataInterpolations.CubicHermiteSpline","text":"CubicHermiteSpline(du, u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a Cubic Hermite interpolation, which is a piece-wise third degree polynomial such that the value and the first derivative are equal to given values in the data points.\n\nArguments\n\ndu: the derivative at the data points.\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.PCHIPInterpolation","page":"Manual","title":"DataInterpolations.PCHIPInterpolation","text":"PCHIPInterpolation(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a PCHIP Interpolation, which is a type of CubicHermiteSpline where the derivative values du are derived from the input data in such a way that the interpolation never overshoots the data. See here, section 3.4 for more details.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DataInterpolations.QuinticHermiteSpline","page":"Manual","title":"DataInterpolations.QuinticHermiteSpline","text":"QuinticHermiteSpline(ddu, du, u, t; extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a Quintic Hermite interpolation, which is a piece-wise fifth degree polynomial such that the value and the first and second derivative are equal to given values in the data points.\n\nArguments\n\nddu: the second derivative at the data points.\ndu: the derivative at the data points.\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Utility-Functions","page":"Manual","title":"Utility Functions","text":"","category":"section"},{"location":"manual/#DataInterpolations.looks_linear","page":"Manual","title":"DataInterpolations.looks_linear","text":"looks_linear(t; threshold = 1e-2)\n\nDetermine if the abscissae t are regularly distributed, taking the standard deviation of the difference between the array of abscissae with respect to the straight line linking its first and last elements, normalized by the range of t. If this standard deviation is below the given threshold, the vector looks linear (return true). Internal function - interface may change.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DataInterpolations.output_dim","page":"Manual","title":"DataInterpolations.output_dim","text":"output_dim(x::AbstractInterpolation)\n\nReturn the number of dimensions ndims(x(t)) of interpolation x for a scalar t.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DataInterpolations.output_size","page":"Manual","title":"DataInterpolations.output_size","text":"output_size(x::AbstractInterpolation)\n\nReturn the size size(x(t)) of interpolation x for a scalar t.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Interpolation-using-different-methods","page":"Interpolation methods","title":"Interpolation using different methods","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"We will use the following data to demonstrate interpolation methods.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"using DataInterpolations, Plots\ngr() # hide\n\n# Dependent variable\nu = [14.7, 11.51, 10.41, 14.95, 12.24, 11.22]\n\n# Independent variable\nt = [0.0, 62.25, 109.66, 162.66, 205.8, 252.3]","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"For each method, we will show how to perform the fit and use the plot recipe to show the fitting curve.","category":"page"},{"location":"methods/#Linear-Interpolation","page":"Interpolation methods","title":"Linear Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is a linear interpolation between the ends points of the interval of input data points.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = LinearInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Quadratic-Interpolation","page":"Interpolation methods","title":"Quadratic Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This function fits a parabola passing through the two nearest points from the input data point as well as the next-closest point on the right or left, depending on whether the forward- or backward-looking mode is selected (default mode is forward-looking). It is continuous and piecewise differentiable.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = QuadraticInterpolation(u, t) # same as QuadraticInterpolation(u,t,:Forward)\n# alternatively: A = QuadraticInterpolation(u,t,:Backward)\nplot(A)","category":"page"},{"location":"methods/#Lagrange-Interpolation","page":"Interpolation methods","title":"Lagrange Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"It fits a polynomial of degree d (=length(t)-1), and is thus a continuously differentiable function.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = LagrangeInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Akima-Interpolation","page":"Interpolation methods","title":"Akima Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This function fits piecewise cubic polynomials which forms a continuously differentiable function. This differs from Cubic Spline as coefficients are computed using only neighbouring points and hence the fit looks more natural.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = AkimaInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Constant-Interpolation","page":"Interpolation methods","title":"Constant Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This function is constant between data points. By default, it takes the value at the left end of the interval. One can change that behavior by passing the keyword argument dir = :right.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = ConstantInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Or using the right endpoints:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = ConstantInterpolation(u, t, dir = :right)\nplot(A)","category":"page"},{"location":"methods/#Smoothed-Constant-Interpolation","page":"Interpolation methods","title":"Smoothed Constant Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This function is much like the constant interpolation above, but the transition between consecutive values is smoothed out so that the function is continuously differentiable. The smoothing is done in such a way that the integral of this function is never much off from the same integral of constant interpolation without smoothing (because of the symmetry of the smoothing sections). The maximum smoothing distance in the t direction from the data points can be set with the keyword argument d_max.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = ConstantInterpolation(u, t)\nplot(A)\nA = SmoothedConstantInterpolation(u, t; d_max = 10)\nplot!(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Note that u[end] is ignored, except when using extrapolation types Constant or Extension.","category":"page"},{"location":"methods/#Quadratic-Spline","page":"Interpolation methods","title":"Quadratic Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the quadratic spline. It is a continuously differentiable interpolation which hits each of the data points exactly. Splines are a local interpolation method, meaning that the curve in a given spot is only affected by the points nearest to it.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = QuadraticSpline(u, t)\nplot(A)","category":"page"},{"location":"methods/#Cubic-Spline","page":"Interpolation methods","title":"Cubic Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the cubic spline. It is a continuously twice differentiable interpolation which hits each of the data points exactly.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = CubicSpline(u, t)\nplot(A)","category":"page"},{"location":"methods/#B-Splines","page":"Interpolation methods","title":"B-Splines","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is an interpolating B-spline. B-splines are a global method, meaning that every data point is taken into account for each point of the curve. The interpolating B-spline is the version which hits each of the points. This method is described in more detail here. Let's plot a cubic B-spline (3rd order). Since the data points are not close to uniformly spaced, we will use the :ArcLen and :Average choices:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = BSplineInterpolation(u, t, 3, :ArcLen, :Average)\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"The approximating B-spline is a smoothed version of the B-spline. It again is a global method. In this case, we need to give a number of control points length(t)>h and this method fits a B-spline through the control points which is a least square approximation. This has a natural effect of smoothing the data. For example, if we use 4 control points, we get the result:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = BSplineApprox(u, t, 3, 4, :ArcLen, :Average)\nplot(A)","category":"page"},{"location":"methods/#Cubic-Hermite-Spline","page":"Interpolation methods","title":"Cubic Hermite Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the cubic (third order) Hermite interpolation. It matches the values and first order derivatives in the data points exactly.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"du = [-0.047, -0.058, 0.054, 0.012, -0.068, 0.0011]\nA = CubicHermiteSpline(du, u, t)\nplot(A)","category":"page"},{"location":"methods/#PCHIP-Interpolation","page":"Interpolation methods","title":"PCHIP Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is a type of CubicHermiteSpline where the derivative values du are derived from the input data in such a way that the interpolation never overshoots the data.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = PCHIPInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Quintic-Hermite-Spline","page":"Interpolation methods","title":"Quintic Hermite Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the quintic (fifth order) Hermite interpolation. It matches the values and first and second order derivatives in the data points exactly.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"ddu = [0.0, -0.00033, 0.0051, -0.0067, 0.0029, 0.0]\ndu = [-0.047, -0.058, 0.054, 0.012, -0.068, 0.0011]\nA = QuinticHermiteSpline(ddu, du, u, t)\nplot(A)","category":"page"},{"location":"methods/#Regularization-Smoothing","page":"Interpolation methods","title":"Regularization Smoothing","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Smoothing by regularization (a.k.a. ridge regression) finds a function hatu that minimizes the objective function:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Q(hatu) = int_t_1^t_N hatu(t) - u(t)^2 mathrmdt + lambda int_hatt_1^hatt_N hatu^(d)(hatt)^2 mathrmd hatt","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"where (d) denotes derivative order and lambda is the regularization (smoothing) parameter. The integrals are evaluated numerically at the set of t values for the first term and hatt values for the second term (equal to t if not provided). Regularization smoothing is a global method that creates a smooth curve directly. See Stickel (2010) Comput. Chem. Eng. 34:467 for details. The implementation in this package uses cubic splines to interpolate between the smoothed points after they are determined.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"using RegularizationTools\nd = 2\nλ = 1e3\nA = RegularizationSmooth(u, t, d; λ = λ, alg = :fixed)\nû = A.û\n# interpolate using the smoothed values\nN = 200\ntitp = collect(range(minimum(t), maximum(t), length = N))\nuitp = A.(titp)\nlw = 1.5\nscatter(t, u, label = \"data\")\nscatter!(t, û, marker = :square, label = \"smoothed data\")\nplot!(titp, uitp, lw = lw, label = \"smoothed interpolation\")","category":"page"},{"location":"methods/#Dense-Data-Demonstration","page":"Interpolation methods","title":"Dense Data Demonstration","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Some methods are better suited for dense data. Let's generate such data to demonstrate these methods.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"import StableRNGs: StableRNG\nrng = StableRNG(318)\nt = sort(10 .* rand(rng, 100))\nu = sin.(t) .+ 0.5 * randn(rng, 100);","category":"page"},{"location":"methods/#Regularization-Smoothing-2","page":"Interpolation methods","title":"Regularization Smoothing","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Although smoothing by regularization can be used to interpolate sparse data as shown above, it is especially useful for dense as well as scattered data (unequally spaced, unordered, and/or repeat-valued). Generalized cross validation (GCV) or so-called L-curve methods can be used to determine an \"optimal\" value for the smoothing parameter. In this example, we perform smoothing in two ways. In the first, we find smooth values at the original t values and then interpolate. In the second, we perform the smoothing for the interpolant hatt values directly. GCV is used to determine the regularization parameter for both cases.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"d = 4\nA = RegularizationSmooth(u, t, d; alg = :gcv_svd)\nû = A.û\nN = 200\ntitp = collect(range(minimum(t), maximum(t), length = N))\nuitp = A.(titp)\nAm = RegularizationSmooth(u, t, titp, d; alg = :gcv_svd)\nûm = Am.û\nscatter(t, u, label = \"simulated data\", legend = :top)\nscatter!(t, û, marker = (:square, 4), label = \"smoothed data\")\nplot!(titp, uitp, lw = lw, label = \"smoothed interpolation\")\nplot!(titp, ûm, lw = lw, linestyle = :dash, label = \"smoothed, more points\")","category":"page"},{"location":"methods/#Curve-Fits","page":"Interpolation methods","title":"Curve Fits","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A curve fit works with both dense and sparse data. We will demonstrate the curve fit on the dense data since we generated it based on sin(t), so this is the curve we want to fit through it. To do so, let's define a similar function with parameters. Let's choose the form:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"m(t, p) = @. p[1] * sin(p[2] * t) + p[3] * cos(p[4] * t)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Notice that this is a function on the whole array of t and expects an array for the predicted u out. This choice of m is based on the assumption that our function is of the form p1*sin(p2*t)+p3*cos(p4*t). We want to find the p to match our data. Let's start with the guess of every p being zero, that is p=ones(4). Then we would fit this curve using:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"using Optim\nA = Curvefit(u, t, m, ones(4), LBFGS())\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"We can check what the fitted parameters are via:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A.pmin","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Notice that it essentially made p3=0 with p1=p2=1, meaning it approximately found sin(t)! But note that the ability to fit is dependent on the initial parameters. For example, with p=zeros(4) as the initial parameters, the fit is not good:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = Curvefit(u, t, m, zeros(4), LBFGS())\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"And the parameters show the issue:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A.pmin","category":"page"},{"location":"#DataInterpolations.jl","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"DataInterpolations.jl is a library for performing interpolations of one-dimensional data. Interpolations are a very important component of many modeling workflows. Often, sampled or measured inputs need to be transformed into continuous functions or smooth curves for simulation purposes. In many scientific machine learning workflows, interpolating data is essential to learn continuous models. DataInterpolations.jl can be used for facilitating these types of workflows. By \"data interpolations\" we mean techniques for interpolating possibly noisy data, and thus some methods are mixtures of regressions with interpolations (i.e. do not hit the data points exactly, smoothing out the lines).","category":"page"},{"location":"#Installation","page":"DataInterpolations.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"To install DataInterpolations.jl, use the Julia package manager:","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using Pkg\nPkg.add(\"DataInterpolations\")","category":"page"},{"location":"#Available-Interpolations","page":"DataInterpolations.jl","title":"Available Interpolations","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"In all cases, u an AbstractVector of values and t is an AbstractVector of timepoints corresponding to (u,t) pairs.","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"ConstantInterpolation(u,t) - A piecewise constant interpolation.\nSmoothedConstantInterpolation(u,t) - An integral preserving continuously differentiable approximation of constant interpolation.\nLinearInterpolation(u,t) - A linear interpolation.\nQuadraticInterpolation(u,t) - A quadratic interpolation.\nLagrangeInterpolation(u,t,n) - A Lagrange interpolation of order n.\nQuadraticSpline(u,t) - A quadratic spline interpolation.\nCubicSpline(u,t) - A cubic spline interpolation.\nAkimaInterpolation(u, t) - Akima spline interpolation provides a smoothing effect and is computationally efficient.\nBSplineInterpolation(u,t,d,pVec,knotVec) - An interpolation B-spline. This is a B-spline that hits each of the data points. The argument choices are:\nd - degree of B-spline\npVec - Symbol to Parameters Vector, pVec = :Uniform for uniformly spaced parameters, and pVec = :ArcLen for parameters generated by the chord length method.\nknotVec - Symbol to Knot Vector, knotVec = :Uniform for uniform knot vector, knotVec = :Average for average spaced knot vector.\nBSplineApprox(u,t,d,h,pVec,knotVec) - A regression B-spline which smooths the fitting curve. The argument choices are the same as the BSplineInterpolation, with the additional parameter h<length(t) which is the number of control points to use, with smaller h indicating more smoothing.\nCubicHermiteSpline(du, u, t) - A third order Hermite interpolation, which matches the values and first (du) order derivatives in the data points exactly.\nPCHIPInterpolation(u, t) - a type of CubicHermiteSpline where the derivative values du are derived from the input data in such a way that the interpolation never overshoots the data.\nQuinticHermiteSpline(ddu, du, u, t) - a fifth order Hermite interpolation, which matches the values and first (du) and second (ddu) order derivatives in the data points exactly.","category":"page"},{"location":"#Extension-Methods","page":"DataInterpolations.jl","title":"Extension Methods","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"The following methods require extra dependencies and will be loaded as package extensions.","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"Curvefit(u,t,m,p,alg) - An interpolation which is done by fitting a user-given functional form m(t,p) where p is the vector of parameters. The user's input p is an initial value for a least-squares fitting, alg is the algorithm choice to use to optimize the cost function (sum of squared deviations) via Optim.jl and optimal ps are used in the interpolation. Requires using Optim.\nRegularizationSmooth(u,t,d;λ,alg) - A regularization algorithm (ridge regression) which is done by minimizing an objective function (l2 loss + derivatives of order d) integrated in the time span. It is a global method which creates a smooth curve. Requires using RegularizationTools.","category":"page"},{"location":"#Plotting","page":"DataInterpolations.jl","title":"Plotting","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"DataInterpolations.jl is tied into the Plots.jl ecosystem, by way of RecipesBase. Any interpolation can be plotted using the plot command (or any other), since they have type recipes associated with them.","category":"page"},{"location":"#Citing","page":"DataInterpolations.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"If you use this software in your work, please cite:","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"@article{Bhagavan2024,\n  doi = {10.21105/joss.06917},\n  url = {https://doi.org/10.21105/joss.06917},\n  year = {2024},\n  publisher = {The Open Journal},\n  volume = {9},\n  number = {101},\n  pages = {6917},\n  author = {Sathvik Bhagavan and Bart de Koning and Shubham Maddhashiya and Christopher Rackauckas},\n  title = {DataInterpolations.jl: Fast Interpolations of 1D data},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"#Contributing","page":"DataInterpolations.jl","title":"Contributing","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"DataInterpolations.jl","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"</details>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"</details>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"</details>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
