<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Smooth arc length interpolation · DataInterpolations.jl</title><meta name="title" content="Smooth arc length interpolation · DataInterpolations.jl"/><meta property="og:title" content="Smooth arc length interpolation · DataInterpolations.jl"/><meta property="twitter:title" content="Smooth arc length interpolation · DataInterpolations.jl"/><meta name="description" content="Documentation for DataInterpolations.jl."/><meta property="og:description" content="Documentation for DataInterpolations.jl."/><meta property="twitter:description" content="Documentation for DataInterpolations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DataInterpolations/stable/arclength_interpolation/"/><meta property="twitter:url" content="https://docs.sciml.ai/DataInterpolations/stable/arclength_interpolation/"/><link rel="canonical" href="https://docs.sciml.ai/DataInterpolations/stable/arclength_interpolation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DataInterpolations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataInterpolations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">DataInterpolations.jl</a></li><li><a class="tocitem" href="../methods/">Interpolation methods</a></li><li><a class="tocitem" href="../extrapolation_methods/">Extrapolation methods</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../symbolics/">Using with Symbolics/ModelingToolkit</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li class="is-active"><a class="tocitem" href>Smooth arc length interpolation</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li><li><a class="tocitem" href="#Method-derivation"><span>Method derivation</span></a></li></ul></li><li><a class="tocitem" href="../inverting_integrals/">Inverting Integrals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Smooth arc length interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Smooth arc length interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DataInterpolations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DataInterpolations.jl/blob/master/docs/src/arclength_interpolation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Smooth-arc-length-interpolation"><a class="docs-heading-anchor" href="#Smooth-arc-length-interpolation">Smooth arc length interpolation</a><a id="Smooth-arc-length-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-arc-length-interpolation" title="Permalink"></a></h1><p>Arc length interpolation is interpolation between points using a curve that is parameterized by arc length. That is: the curve parameterization has unit speed everywhere, and so the parameter <code>t</code> at each point on the curve is equal to the total distance traveled from the beginning of the curve. In this context, by &#39;smooth&#39; we mean that the curve is continuously differentiable.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p><code>DataInteprolations.jl</code> offers an arc length interpolation method that approximates an existing non arc length interpolation by circle and line segments. This can be done by providing an interpolation object (the shape interpolation):</p><pre><code class="language-julia hljs">using DataInterpolations
using Plots
using Random

Random.seed!(2)

# Example from interpolation object
u = cumsum([rand(3) for _ in 1:10])
t = 1:10
A_shape = QuadraticSpline(u, t)
A = SmoothArcLengthInterpolation(A_shape; m = 10)

function plot_itp(itp)
    t_eval = range(itp.t[1], itp.t[end]; length = 1000)
    u_eval = zeros(3, 1000)
    itp(u_eval, t_eval)

    plot(eachrow(u_eval)...; label = &quot;SmoothArcLengthInterpolation&quot;)
    scatter!(eachrow(u_eval[:, 1:50:end])...; label = &quot;Equidistant points on the curve&quot;)
    scatter!(eachrow(hcat(A.shape_itp.u...))...; label = &quot;Original data&quot;)
end

plot_itp(A)</code></pre><img src="bcf6ae73.svg" alt="Example block output"/><p>Here <code>m</code> determines how fine the approximation is. It is also possible to just provide the data points, optionally providing <code>t</code> and a preferred interpolation type which determines the shape of the curve.</p><pre><code class="language-julia hljs">using LinearAlgebra

# Example from only u
A = SmoothArcLengthInterpolation(hcat(u...))
@show typeof(A.shape_itp)
plot_itp(A)</code></pre><img src="0ba69219.svg" alt="Example block output"/><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataInterpolations.SmoothArcLengthInterpolation-Union{Tuple{AbstractMatrix{U}}, Tuple{U}} where U" href="#DataInterpolations.SmoothArcLengthInterpolation-Union{Tuple{AbstractMatrix{U}}, Tuple{U}} where U"><code>DataInterpolations.SmoothArcLengthInterpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> SmoothArcLengthInterpolation(
    u::AbstractMatrix{U};
    t::Union{AbstractVector, Nothing} = nothing,
    interpolation_type::Type{&lt;:AbstractInterpolation} = QuadraticSpline,
    kwargs...) where {U}</code></pre><p>Interpolate in a C¹ smooth way through the data with unit speed by approximating an interpolation (the shape interpolation) with line segments and circle segments.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: The data to be interpolated in matrix form; (ndim, ndata).</li></ul><p>NOTE: With this method it is not possible to pass keyword arguments to the constructor of the shape interpolation. If you want to do this, construct the shape interpolation yourself and use the <code>SmoothArcLengthInterpolation(shape_itp::AbstractInterpolation; kwargs...)</code> method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>t</code>: The time points of the shape interpolation. By default given by the cumulative sum of the Euclidean distances between the points <code>u</code>.</li><li><code>interpolation_type</code>: The type of the shape interpolation. Defaults to <code>QuadraticSpline</code>. Note that for the <code>SmoothArcLengthInterpolation</code> to be C¹ smooth, the <code>interpolation_type</code> must be C¹ smooth as well.</li><li><code>m</code>: The number of points at which the shape interpolation is evaluated in each interval between time points. The <code>SmoothArcLengthInterpolation</code> converges to the shape interpolation (in shape) as m → ∞.</li><li><code>extrapolation</code>: The extrapolation type applied left and right of the data. Possible options are <code>ExtrapolationType.None</code> (default), <code>ExtrapolationType.Constant</code>, <code>ExtrapolationType.Linear</code> <code>ExtrapolationType.Extension</code>, <code>ExtrapolationType.Periodic</code> and <code>ExtrapolationType.Reflective</code>.</li><li><code>extrapolation_left</code>: The extrapolation type applied left of the data. See <code>extrapolation</code> for the possible options. This keyword is ignored if <code>extrapolation != Extrapolation.none</code>.</li><li><code>extrapolation_right</code>: The extrapolation type applied right of the data. See <code>extrapolation</code> for the possible options. This keyword is ignored if <code>extrapolation != Extrapolation.none</code>.</li><li><code>assume_linear_t</code>: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see <a href="../manual/#DataInterpolations.looks_linear"><code>looks_linear</code></a>). Defaults to 1e-2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DataInterpolations.jl/blob/58e5ce5fbad02cccfee96621c85ddcbee6f708cb/src/interpolation_caches.jl#L1459-L1496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataInterpolations.SmoothArcLengthInterpolation-Tuple{DataInterpolations.AbstractInterpolation}" href="#DataInterpolations.SmoothArcLengthInterpolation-Tuple{DataInterpolations.AbstractInterpolation}"><code>DataInterpolations.SmoothArcLengthInterpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function SmoothArcLengthInterpolation(
        shape_itp::AbstractInterpolation;
        m::Integer = 2,
        kwargs...)</code></pre><p>Approximate the <code>shape_itp</code> with a C¹ unit speed interpolation using line segments and circle segments.</p><p><strong>Arguments</strong></p><ul><li><code>shape_itp</code>: The interpolation to be approximated. Note that for the <code>SmoothArcLengthInterpolation</code> to be C¹ smooth, the <code>shape_itp</code> must be C¹ smooth as well.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>m</code>: The number of points at which the shape interpolation is evaluated in each interval between time points. The <code>SmoothArcLengthInterpolation</code> converges to the shape interpolation (in shape) as m → ∞.</li><li><code>extrapolation</code>: The extrapolation type applied left and right of the data. Possible options are <code>ExtrapolationType.None</code> (default), <code>ExtrapolationType.Constant</code>, <code>ExtrapolationType.Linear</code> <code>ExtrapolationType.Extension</code>, <code>ExtrapolationType.Periodic</code> and <code>ExtrapolationType.Reflective</code>.</li><li><code>extrapolation_left</code>: The extrapolation type applied left of the data. See <code>extrapolation</code> for the possible options. This keyword is ignored if <code>extrapolation != Extrapolation.none</code>.</li><li><code>extrapolation_right</code>: The extrapolation type applied right of the data. See <code>extrapolation</code> for the possible options. This keyword is ignored if <code>extrapolation != Extrapolation.none</code>.</li><li><code>assume_linear_t</code>: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see <a href="../manual/#DataInterpolations.looks_linear"><code>looks_linear</code></a>). Defaults to 1e-2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DataInterpolations.jl/blob/58e5ce5fbad02cccfee96621c85ddcbee6f708cb/src/interpolation_caches.jl#L1518-L1546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataInterpolations.SmoothArcLengthInterpolation-Tuple{AbstractMatrix, AbstractMatrix}" href="#DataInterpolations.SmoothArcLengthInterpolation-Tuple{AbstractMatrix, AbstractMatrix}"><code>DataInterpolations.SmoothArcLengthInterpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function SmoothArcLengthInterpolation(
    u::AbstractMatrix,
    d::AbstractMatrix
    [, make_intersections::Val{&lt;:Bool}];
    shape_itp::Union{AbstractInterpolation, Nothing} = nothing,
    extrapolation::ExtrapolationType.T = ExtrapolationType.None,
    extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,
    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None,
    cache_parameters::Bool = false,
    assume_linear_t = 1e-2,
    in_place::Bool = true)</code></pre><p>Make a C¹ smooth unit speed interpolation through the given data with the given tangents using line segments and circle segments.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: The data to be interpolated in matrix form; (ndim, ndata).</li><li><code>d</code>: The tangents to the curve in the points <code>u</code>.</li><li><code>make_intersections</code>: Whether additional (point, tangent) pairs have to be added in between the provided data to ensure that the consecutive (tangent) lines intersect. Defaults to <code>Val(true)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shape_itp</code>: The interpolation that is being approximated, if one exists. Note that this interpolation is not being used; it is just passed along to keep track of where the shape of the <code>SmoothArcLengthInterpolation</code> originated.</li><li><code>extrapolation</code>: The extrapolation type applied left and right of the data. Possible options are <code>ExtrapolationType.None</code> (default), <code>ExtrapolationType.Constant</code>, <code>ExtrapolationType.Linear</code> <code>ExtrapolationType.Extension</code>, <code>ExtrapolationType.Periodic</code> and <code>ExtrapolationType.Reflective</code>.</li><li><code>extrapolation_left</code>: The extrapolation type applied left of the data. See <code>extrapolation</code> for the possible options. This keyword is ignored if <code>extrapolation != Extrapolation.none</code>.</li><li><code>extrapolation_right</code>: The extrapolation type applied right of the data. See <code>extrapolation</code> for the possible options. This keyword is ignored if <code>extrapolation != Extrapolation.none</code>.</li><li><code>assume_linear_t</code>: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see <a href="../manual/#DataInterpolations.looks_linear"><code>looks_linear</code></a>). Defaults to 1e-2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DataInterpolations.jl/blob/58e5ce5fbad02cccfee96621c85ddcbee6f708cb/src/interpolation_caches.jl#L1584-L1623">source</a></section></article><h2 id="Method-derivation"><a class="docs-heading-anchor" href="#Method-derivation">Method derivation</a><a id="Method-derivation-1"></a><a class="docs-heading-anchor-permalink" href="#Method-derivation" title="Permalink"></a></h2><p>Say we have an ordered set of points <span>$u_1, \ldots, u_n \in \mathbb{R}^N$</span> and we want to make a lightweight <span>$C^1$</span> smooth interpolation by arc-length <span>$\tilde{\gamma}: [0,T] \rightarrow \mathbb{R}^N$</span> through these points. The first part is easy, just pick your favorite established interpolation method that achieves <span>$C^1$</span> smoothness. The arc-length part however turns out to be quite <a href="https://ijpam.eu/contents/2006-31-3/10/10.pdf">nasty</a>. Here I propose a method that is quite general and cheap to compute.</p><h3 id="The-2-dimensional-case"><a class="docs-heading-anchor" href="#The-2-dimensional-case">The 2-dimensional case</a><a id="The-2-dimensional-case-1"></a><a class="docs-heading-anchor-permalink" href="#The-2-dimensional-case" title="Permalink"></a></h3><p>2 is the smallest number of dimensions in which the posed problem is non-trivial. Say we use an established (non arc-length) interpolation method for our set of points to obtain the <span>$C^1$</span> curve</p><p class="math-container">\[    \gamma : [0, T] \rightarrow \mathbb{R}^2\]</p><p>for which</p><p class="math-container">\[    \gamma(t_i) = u_i \quad i = 1, \ldots, n,\]</p><p>given a suitable set of &#39;time&#39; values</p><p class="math-container">\[    0 = t_1 &lt; t_2 &lt; \ldots &lt; t_n = T,\]</p><p>for instance</p><p class="math-container">\[    t_i = \sum_{k=1}^{i-1} \|u_{k+1} - u_k\|_2.\]</p><p>We now want to approximate <span>$\gamma$</span> piecewise with sections that are trivially parameterizable by arc-length, namely line segments and circle segments. To do this, we fix some <span>$m \in \mathbb{N}$</span> and define a refined set of time points <span>$\left(\tilde{t}_j\right)_{j=1}^{m(n-1) + 1}$</span> given by</p><p class="math-container">\[    \tilde{t}_{m(k-1) + l} = t_k + \frac{l}{m + 1}(t_{k+1} - t_k), \quad k = 1 \ldots n-1, \; l = 1, \ldots m.\]</p><p>In these refined time points we evaluate <span>$\gamma$</span> and its normalized derivative:</p><p class="math-container">\[    \tilde{u}_j = \gamma\left(\tilde{t}_j\right), \; \tilde{d}_j = \frac{\dot{\gamma}\left(\tilde{t}_j\right)}{\|\dot{\gamma}\left(\tilde{t}_j\right)\|_2}, \qquad j = 1, \ldots, m(n-1) + 1.\]</p><p>As a first step to create the interpolation by arc length <span>$\tilde{\gamma}$</span>, we make a piecewise linear curve which is tangent to <span>$\gamma$</span> in <span>$\tilde{u}_j$</span> for each line segment, where we denote the intersection of consecutive tangent lines by <span>$\tilde{u}_{j, \text{int}}$</span>:</p><p class="math-container">\[    \begin{align*}
    \tilde{u}_{j, \text{int}} &amp;=&amp; \tilde{u}_j + \frac{\langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_j\rangle - \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle \langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_{j+1}\rangle}{1 - \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle^2}\tilde{d}_j \\
    &amp;=&amp; \tilde{u}_{j+1} + \frac{\langle\tilde{d}_j, \tilde{d}_{j+1}\rangle\langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_j\rangle - \langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_{j+1}\rangle}{1 - \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle^2}\tilde{d}_{j+1}.
    \end{align*}\]</p><p>As expected this doesn&#39;t work for <span>$\langle\tilde{d}_j, \tilde{d}_{j+1}\rangle^2 = 1$</span>, which means that the consecutive tangent lines are parallel. In fact, in the above equation we want the coefficient of <span>$\tilde{d}_j$</span> to be positive and the coefficient of <span>$\tilde{d}_{j+1}$</span> to be negative, to ensure that <span>$\tilde{u}_{j, \text{int}}$</span> lies properly in between <span>$\tilde{u}_j$</span> and <span>$\tilde{u}_{j+1}$</span>.</p><img src="fe553942.svg" alt="Example block output"/><p>As a last step to obtain our curve by arc length <span>$\tilde{\gamma}$</span> we want to get rid of the kinks in the tangent curve. We do this by replacing sections of the tangent curve by circle arcs. For each <span>$\tilde{u}_{j, \text{int}}$</span> we compute the shortest distance to the neighboring evaluation points on <span>$\gamma$</span>:</p><p class="math-container">\[    \delta_j = \min\left\{
        \|\tilde{u}_j - \tilde{u}_{j, \text{int}}\|_2, 
        \|\tilde{u}_{j + 1} - \tilde{u}_{j, \text{int}}\|_2
    \right\}.\]</p><p>From this we compute 2 points that are on the tangent curve and equidistant from <span>$\tilde{u}_{j  + \frac{1}{2}}$</span>:</p><p class="math-container">\[    \tilde{u}_{j, \text{start}} = \tilde{u}_{j, \text{int}} - \delta_j \tilde{d}_j, \]</p><p class="math-container">\[    \tilde{u}_{j, \text{end}} = \tilde{u}_{j, \text{int}} + \delta_j \tilde{d}_{j+1}.\]</p><p>Note that by this definition</p><p class="math-container">\[    \tilde{u}_{j, \text{start}} = \tilde{u}_j \quad \vee \quad \tilde{u}_{j, \text{end}} = \tilde{u}_{j  + 1}.\]</p><p>Now we can define a circle arc from <span>$\tilde{u}_{j, \text{start}}$</span> to <span>$\tilde{u}_{j, \text{end}}$</span> given the center</p><p class="math-container">\[    c_j = \tilde{u}_{j, \text{int}} + \delta_j\frac{\tilde{d}_{j+1} - \tilde{d}_j}{1 - \langle\tilde{d}_j,\tilde{d}_{j+1}\rangle}\]</p><p>and radius</p><p class="math-container">\[    R_j = \delta_j\sqrt{\frac{1 + \langle\tilde{d}_j,\tilde{d}_{j+1}\rangle}{1 - \langle\tilde{d}_j,\tilde{d}_{j+1}\rangle}}.\]</p><p>We obtain the circle arc</p><p class="math-container">\[    c_j + \cos\left(\frac{t}{R_j}\right)v_{j, 1} + \sin\left(\frac{t}{R_j}\right)v_{j, 2}, \quad t \in [0, \Delta t_{j, \text{arc}}],\]</p><p>where</p><p class="math-container">\[    v_{j, 1} = -\delta_j \frac{\tilde{d}_{j+1} - \langle\tilde{d}_j,\tilde{d}_{j+1}\rangle\tilde{d}_j}{1 - \langle\tilde{d}_j,\tilde{d}_{j+1}\rangle},
    \quad
    v_{j, 2} = R_j \tilde{d}_j.\]</p><p>By this definition <span>$\|v_{j, 1}\|_2 = \|v_{j, 2}\|_2 = R_j$</span> and <span>$\langle v_{j, 1}, v_{j, 2}\rangle = 0$</span>. Furthermore:</p><p class="math-container">\[    \Delta t_{j, \text{arc}} = R_j\theta_{j, \;\max}= 2R_j \arctan\left(\frac{\delta_j}{R_j}\right).\]</p><img src="428627fd.svg" alt="Example block output"/><img src="19977e4b.svg" alt="Example block output"/><p>That&#39;s pretty neat, but this method does not directly generalize to higher dimensional spaces. That is because in general the intersection points <span>$\tilde{u}_{j, \text{int}}$</span> of the tangent lines do not exist.</p><h3 id="The-higher-dimensional-case"><a class="docs-heading-anchor" href="#The-higher-dimensional-case">The higher dimensional case</a><a id="The-higher-dimensional-case-1"></a><a class="docs-heading-anchor-permalink" href="#The-higher-dimensional-case" title="Permalink"></a></h3><p>Let&#39;s try to generalize the method above. The goal is to find a point <span>$\tilde{u}_{j + \frac{1}{2}}$</span> and unit direction <span>$\tilde{d}_{j + \frac{1}{2}}$</span> to add to the tangent curve between <span>$\tilde{u}_j$</span> and <span>$\tilde{u}_{j+1}$</span> such that:</p><ul><li>the tangent line intersections <span>$\tilde{u}_{j, \text{int left}}, \tilde{u}_{j, \text{int right}}$</span> exist. This means that the new line is fixed by these 2 points;</li><li>constructing <span>$\tilde{\gamma}$</span> including this point gives gives an identical result to constructing <span>$\tilde{\gamma}$</span> excluding this point if the tangent line intersection already existed. The latter implies that <span>$\tilde{u}_{j + \frac{1}{2}}$</span> and <span>$\tilde{d}_{j + \frac{1}{2}}$</span> yield a tangent line to the constructed circle arc.</li></ul><p>Let&#39;s assume the tangent line intersection exists, and we define</p><p class="math-container">\[    \tilde{u}_{j, \text{int left}} = \tilde{u}_{j, \text{int}} - \delta_j^* \tilde{d}_{j},\]</p><p class="math-container">\[    \tilde{u}_{j, \text{int right}} = \tilde{u}_{j, \text{int}} + \delta_j^* \tilde{d}_{j+1}.\]</p><p>It turns out that if we then let</p><p class="math-container">\[\delta^*_j = \delta_j \frac{2 - \sqrt{2 + 2 \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle}}{1 - \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle},\]</p><p>The line between <span>$\tilde{u}_{, \text{int left}}$</span> and $ \tilde{u}_{, \text{int right}}$ touches the circle arc as constructed before. It follows that</p><p class="math-container">\[    \tilde{u}_{j + \frac{1}{2}} = \frac{1}{2}\left[\tilde{u}_{j, \text{int left}} + \tilde{u}_{j, \text{int right}}\right],
    \qquad
    \tilde{d}_{j + \frac{1}{2}} = \frac{\tilde{u}_{j, \text{int right}} - \tilde{u}_{j, \text{int left}}}{\|\tilde{u}_{j, \text{int right}} - \tilde{u}_{j, \text{int left}}\|_2}.\]</p><img src="6fc43b8f.svg" alt="Example block output"/><p>If we generalize the definition of <span>$\tilde{u}_{j, \text{int}}$</span> then we can compute  <span>$\tilde{u}_{j + \frac{1}{2}}$</span> and <span>$\tilde{d}_{j + \frac{1}{2}}$</span> as above. Something we can always compute are the points on the tangent lines which are closest together, given by:</p><p class="math-container">\[    \argmin_{s,\; t \;\in\; \mathbb{R}} \|\tilde{u}_{j+1} + s\tilde{d}_{j+1} - (\tilde{u}_j + t\tilde{d}_j)\|_2.\]</p><p>This yields</p><p class="math-container">\[    \tilde{u}_{j, \text{close left}} = \tilde{u}_j + \frac{\langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_j\rangle - \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle \langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_{j+1}\rangle}{1 - \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle^2}\tilde{d}_j,\]</p><p class="math-container">\[    \tilde{u}_{j, \text{close right}} = \tilde{u}_{j+1} + \frac{\langle\tilde{d}_j, \tilde{d}_{j+1}\rangle\langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_j\rangle - \langle\tilde{u}_{j+1}-\tilde{u}_j, \tilde{d}_{j+1}\rangle}{1 - \langle\tilde{d}_j, \tilde{d}_{j+1}\rangle^2}\tilde{d}_{j+1}.\]</p><p>This is the same as the two expressions for <span>$\tilde{u}_{j, \text{int}}$</span> from before, except now these expressions aren&#39;t necessarily equal. We define <span>$\tilde{u}_{j, \text{int}}$</span> as the average of these expressions:</p><p class="math-container">\[    \tilde{u}_{j, \text{int}} = \frac{\tilde{u}_{j, \text{close left}} + \tilde{u}_{j, \text{close right}}}{2}.\]</p><p>From this <span>$\delta_j$</span> and <span>$\delta_j^*$</span> follow, and</p><p class="math-container">\[    \tilde{u}_{j, \text{int left}} = \tilde{u}_{j, \text{close left}} - \delta_j^* \tilde{d}_{j},\]</p><p class="math-container">\[    \tilde{u}_{j, \text{int right}} = \tilde{u}_{j, \text{close right}} + \delta_j^* \tilde{d}_{j+1}.\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« Manual</a><a class="docs-footer-nextpage" href="../inverting_integrals/">Inverting Integrals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 15 September 2025 10:54">Monday 15 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
