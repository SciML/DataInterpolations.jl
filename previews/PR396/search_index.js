var documenterSearchIndex = {"docs":
[{"location":"symbolics/#Using-DataInterpolations.jl-with-Symbolics.jl-and-ModelingToolkit.jl","page":"Using with Symbolics/ModelingToolkit","title":"Using DataInterpolations.jl with Symbolics.jl and ModelingToolkit.jl","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"All interpolation methods can be integrated with Symbolics.jl and ModelingToolkit.jl seamlessly.","category":"page"},{"location":"symbolics/#Using-with-Symbolics.jl","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics.jl","text":"","category":"section"},{"location":"symbolics/#Expressions","page":"Using with Symbolics/ModelingToolkit","title":"Expressions","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"using DataInterpolations, Symbolics\nusing Test\n\nu = [0.0, 1.5, 0.0]\nt = [0.0, 0.5, 1.0]\nA = LinearInterpolation(u, t)\n\n@variables τ\n\n# Simple Expression\nex = cos(τ) * A(τ)\n@test substitute(ex, Dict(τ => 0.5)) == cos(0.5) * A(0.5) # true","category":"page"},{"location":"symbolics/#Symbolic-Derivatives","page":"Using with Symbolics/ModelingToolkit","title":"Symbolic Derivatives","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"D = Differential(τ)\n\nex1 = A(τ)\n\n# Derivative of interpolation\nex2 = expand_derivatives(D(ex1))\n\n@test substitute(ex2, Dict(τ => 0.5)) == DataInterpolations.derivative(A, 0.5) # true\n\n# Higher Order Derivatives\nex3 = expand_derivatives(D(D(A(τ))))\n\n@test substitute(ex3, Dict(τ => 0.5)) == DataInterpolations.derivative(A, 0.5, 2) # true","category":"page"},{"location":"symbolics/#Using-with-ModelingToolkit.jl","page":"Using with Symbolics/ModelingToolkit","title":"Using with ModelingToolkit.jl","text":"","category":"section"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"Most common use case with ModelingToolkit.jl is to plug in interpolation objects as input functions. This can be done using TimeVaryingFunction component of ModelingToolkitStandardLibrary.jl.","category":"page"},{"location":"symbolics/","page":"Using with Symbolics/ModelingToolkit","title":"Using with Symbolics/ModelingToolkit","text":"using DataInterpolations\nusing ModelingToolkitStandardLibrary.Blocks\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEq\n\nus = [0.0, 1.5, 0.0]\ntimes = [0.0, 0.5, 1.0]\nA = LinearInterpolation(us, times)\n\n@named src = TimeVaryingFunction(A)\nvars = @variables x(t) out(t)\neqs = [out ~ src.output.u, D(x) ~ 1 + out]\n@named sys = ODESystem(eqs, t, vars, []; systems = [src])\n\nsys = structural_simplify(sys)\nprob = ODEProblem(sys, [x => 0.0], (times[1], times[end]))\nsol = solve(prob)","category":"page"},{"location":"extrapolation_methods/#Extrapolation-methods","page":"Extrapolation methods","title":"Extrapolation methods","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"We will use the following interpolation to demonstrate the various extrapolation methods.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"using DataInterpolations, Plots\n\nu = [0.86, 0.65, 0.44, 0.76, 0.73]\nt = [0.0022, 0.68, 1.41, 2.22, 2.46]\nt_eval_left = range(-1, first(t), length = 25)\nt_eval_right = range(last(t), 3.5, length = 25)\nA = QuadraticSpline(u, t)\nplot(A)","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"Extrapolation behavior can be set left and right of the data simultaneously with the extension keyword, or left and right separately with the extrapolation_left and extrapolation_right keywords respectively.","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.None","page":"Extrapolation methods","title":"ExtrapolationType.None","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type will throw an error when the input t is beyond the data in the specified direction.","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Constant","page":"Extrapolation methods","title":"ExtrapolationType.Constant","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type extends the interpolation with the boundary values of the data u.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Constant)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation left\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation right\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Linear","page":"Extrapolation methods","title":"ExtrapolationType.Linear","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type extends the interpolation with a linear continuation of the interpolation, making it C^1 smooth at the data boundaries.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Linear)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation left\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation right\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Extension","page":"Extrapolation methods","title":"ExtrapolationType.Extension","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"This extrapolation type extends the interpolation with a continuation of the expression for the interpolation at the boundary intervals for maximum smoothness.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Extension)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation down\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation up\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Periodic","page":"Extrapolation methods","title":"ExtrapolationType.Periodic","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"this extrapolation type extends the interpolation such that A(t + T) == A(t) for all t, where the period is given by T = last(A.t) - first(A.t).","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"T = last(A.t) - first(A.t)\nt_eval_left = range(first(t) - 2T, first(t), length = 100)\nt_eval_right = range(last(t), last(t) + 2T, length = 100)\nA = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Periodic)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation down\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation up\")","category":"page"},{"location":"extrapolation_methods/#ExtrapolationType.Reflective","page":"Extrapolation methods","title":"ExtrapolationType.Reflective","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"this extrapolation type extends the interpolation such that A(t_ + t) == A(t_ - t) for all t_, t such that (t_ - first(A.t)) % T == 0 and 0 < t < T, where T = last(A.t) - first(A.t).","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation = ExtrapolationType.Reflective)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation down\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation up\")","category":"page"},{"location":"extrapolation_methods/#Mixed-extrapolation","page":"Extrapolation methods","title":"Mixed extrapolation","text":"","category":"section"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"You can also have different extrapolation types left and right of the data.","category":"page"},{"location":"extrapolation_methods/","page":"Extrapolation methods","title":"Extrapolation methods","text":"A = QuadraticSpline(u, t; extrapolation_left = ExtrapolationType.Reflective,\n    extrapolation_right = ExtrapolationType.Periodic)\nplot(A)\nplot!(t_eval_left, A.(t_eval_left); label = \"extrapolation left\")\nplot!(t_eval_right, A.(t_eval_right); label = \"extrapolation right\")","category":"page"},{"location":"inverting_integrals/#Inverting-integrals","page":"Inverting Integrals","title":"Inverting integrals","text":"","category":"section"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"Solving implicit integral problems of the following form is supported:","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"beginequation\n    textfind t such that  int_t_1^t f(tau)textdtau = V ge 0\nendequation","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"where t_1 is given by first(A.t). This is supported for interpolations f that are strictly positive and of one of these types:","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"ConstantInterpolation\nLinearInterpolation","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"This is achieved by creating an 'integral inverse' interpolation object which can efficiently compute t for a given value of V, see the example below.","category":"page"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"using Random #hide\nRandom.seed!(1234) # hide\nusing DataInterpolations\nusing Plots\n\n# Create LinearInterpolation object from the\nu = sqrt.(1:25) + (2.0 * rand(25) .- 1.0) / 3\nt = cumsum(rand(25))\nA = LinearInterpolation(u, t)\n\n# Create LinearInterpolationIntInv object\n# from the LinearInterpolation object\nA_intinv = DataInterpolations.invert_integral(A)\n\n# Get the t values up to and including the\n# solution to the integral problem\nV = 25.0\nt_ = A_intinv(V)\nts = t[t .<= t_]\npush!(ts, t_)\n\n# Plot results\nplot(A; label = \"Linear Interpolation\")\nplot!(ts, A.(ts), fillrange = 0.0, fillalpha = 0.75,\n    fc = :blues, lw = 0, label = \"Area of $V\")","category":"page"},{"location":"inverting_integrals/#Docstrings","page":"Inverting Integrals","title":"Docstrings","text":"","category":"section"},{"location":"inverting_integrals/","page":"Inverting Integrals","title":"Inverting Integrals","text":"DataInterpolations.invert_integral\nConstantInterpolationIntInv\nLinearInterpolationIntInv","category":"page"},{"location":"inverting_integrals/#DataInterpolations.invert_integral","page":"Inverting Integrals","title":"DataInterpolations.invert_integral","text":"invert_integral(A::AbstractInterpolation)::AbstractIntegralInverseInterpolation\n\nCreates the inverted integral interpolation object from the given interpolation. Conditions:\n\nThe range of A must be strictly positive\nA.u must be a number type (on which an ordering is defined)\nThis is currently only supported for ConstantInterpolation and LinearInterpolation\n\nArguments\n\nA: interpolation object satisfying the above requirements\n\n\n\n\n\n","category":"function"},{"location":"inverting_integrals/#DataInterpolations.ConstantInterpolationIntInv","page":"Inverting Integrals","title":"DataInterpolations.ConstantInterpolationIntInv","text":"ConstantInterpolationIntInv(u, t, A)\n\nIt is the interpolation of the inverse of the integral of a ConstantInterpolation. Can be easily constructed with invert_integral(A::ConstantInterpolation{<:AbstractVector{<:Number}})\n\nArguments\n\nu : Given by A.t\nt : Given by A.I (the cumulative integral of A)\nA : The ConstantInterpolation object\n\n\n\n\n\n","category":"type"},{"location":"inverting_integrals/#DataInterpolations.LinearInterpolationIntInv","page":"Inverting Integrals","title":"DataInterpolations.LinearInterpolationIntInv","text":"LinearInterpolationIntInv(u, t, A)\n\nIt is the interpolation of the inverse of the integral of a LinearInterpolation. Can be easily constructed with invert_integral(A::LinearInterpolation{<:AbstractVector{<:Number}})\n\nArguments\n\nu : Given by A.t\nt : Given by A.I (the cumulative integral of A)\nA : The LinearInterpolation object\n\n\n\n\n\n","category":"type"},{"location":"interface/#Interface-for-using-the-Interpolations-object","page":"Interface","title":"Interface for using the Interpolations object","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"We will again use the same data as the previous tutorial to demonstrate how to use the Interpolations object for computing interpolated values at any time point, as well as derivatives and integrals.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"using DataInterpolations\n\n# Dependent variable\nu = [14.7, 11.51, 10.41, 14.95, 12.24, 11.22]\n\n# Independent variable\nt = [0.0, 62.25, 109.66, 162.66, 205.8, 252.3]","category":"page"},{"location":"interface/#Interpolated-values","page":"Interface","title":"Interpolated values","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All interpolation methods return an object from which we can compute the value of the dependent variable at any time point.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"We will use the CubicSpline method for demonstration, but the API is the same for all the methods. We can also pass the extrapolation = ExtrapolationType.Extension keyword if we want to allow the interpolation to go beyond the range of the timepoints in the positive t direction. The default value is extrapolation = ExtrapolationType.None. For more information on extrapolation see Extrapolation methods.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"A1 = CubicSpline(u, t)\n\n# For interpolation do, A(t)\nA1(100.0)\n\nA2 = CubicSpline(u, t; extrapolation = ExtrapolationType.Extension)\n\n# Extrapolation\nA2(300.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"note: Note\nThe values computed beyond the range of the time points provided during interpolation will not be reliable, as these methods only perform well within the range and the first/last piece polynomial fit is extrapolated on either side which might not reflect the true nature of the data.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The keyword cache_parameters = true can be passed to precalculate parameters at initialization, making evalations cheaper to compute. This is not compatible with modifying u and t. The default cache_parameters = false does however not prevent allocation in every interpolation constructor call.","category":"page"},{"location":"interface/#Derivatives","page":"Interface","title":"Derivatives","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Derivatives of the interpolated curves can also be computed at any point for all the methods. Derivatives upto second order is supported where first order derivative is computed analytically and second order using ForwardDiff.jl. Order is passed as the third argument. It is 1 by default.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"We will continue with the above example, but the API is the same for all the methods. If the interpolation is defined with extrapolate=true, derivatives can also be extrapolated.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# derivative(A, t)\nDataInterpolations.derivative(A1, 1.0, 1)\nDataInterpolations.derivative(A1, 1.0, 2)\n\n# Extrapolation\nDataInterpolations.derivative(A2, 300.0)","category":"page"},{"location":"interface/#Integrals","page":"Interface","title":"Integrals","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Integrals of the interpolated curves can also be computed easily.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"note: Note\nIntegrals for LagrangeInterpolation, BSplineInterpolation, BSplineApprox, Curvefit will error as there are no simple analytical solutions available. Please use numerical methods instead, such as Integrals.jl.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"To compute the integrals from the start of time points provided during interpolation to any point, we can do:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# integral(A, t)\nDataInterpolations.integral(A1, 5.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"If we want to compute integrals between two points, we can do:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# integral(A, t1, t2)\nDataInterpolations.integral(A1, 1.0, 5.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Again, if the interpolation is defined with extrapolate=true, the integral can be computed beyond the range of the timepoints.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# integral(A, t1, t2)\nDataInterpolations.integral(A2, 200.0, 300.0)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"note: Note\nIf the times provided in the integral go beyond the range of the time points provided during interpolation, it uses extrapolation methods to compute the values, and hence the integral can be misrepsentative and might not reflect the true nature of the data.","category":"page"},{"location":"manual/#Methods","page":"Manual","title":"Methods","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"LinearInterpolation\nQuadraticInterpolation\nLagrangeInterpolation\nAkimaInterpolation\nConstantInterpolation\nQuadraticSpline\nCubicSpline\nBSplineInterpolation\nBSplineApprox\nCubicHermiteSpline\nPCHIPInterpolation\nQuinticHermiteSpline","category":"page"},{"location":"manual/#DataInterpolations.LinearInterpolation","page":"Manual","title":"DataInterpolations.LinearInterpolation","text":"LinearInterpolation(u, t; extrapolation_left::ExtrapolationType.T = ExtrapolationType.None, \nextrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, \ncache_parameters = false)\n\nIt is the method of interpolating between the data points using a linear polynomial. For any point, two data points one each side are chosen and connected with a line. Extrapolation extends the last linear polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behavior for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.QuadraticInterpolation","page":"Manual","title":"DataInterpolations.QuadraticInterpolation","text":"QuadraticInterpolation(u, t, mode = :Forward; extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, \n    cache_parameters = false)\n\nIt is the method of interpolating between the data points using quadratic polynomials. For any point, three data points nearby are taken to fit a quadratic polynomial. Extrapolation extends the last quadratic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\nmode: :Forward or :Backward. If :Forward, two data points ahead of the point and one data point behind is taken for interpolation. If :Backward, two data points behind and one ahead is taken for interpolation.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.LagrangeInterpolation","page":"Manual","title":"DataInterpolations.LagrangeInterpolation","text":"LagrangeInterpolation(u, t, n = length(t) - 1; extrapolation::ExtrapolationType.T = ExtrapolationType.None, \nextrapolation_left::ExtrapolationType.T = ExtrapolationType.None, extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is the method of interpolation using Lagrange polynomials of (k-1)th order passing through all the data points where k is the number of data points.\n\nArguments\n\nu: data points.\nt: time points.\nn: order of the polynomial. Currently only (k-1)th order where k is the number of data points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.AkimaInterpolation","page":"Manual","title":"DataInterpolations.AkimaInterpolation","text":"AkimaInterpolation(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a spline interpolation built from cubic polynomials. It forms a continuously differentiable function. For more details, refer: https://en.wikipedia.org/wiki/Akima_spline. Extrapolation extends the last cubic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.ConstantInterpolation","page":"Manual","title":"DataInterpolations.ConstantInterpolation","text":"ConstantInterpolation(u, t; dir = :left, extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is the method of interpolating using a constant polynomial. For any point, two adjacent data points are found on either side (left and right). The value at that point depends on dir. If it is :left, then the value at the left point is chosen and if it is :right, the value at the right point is chosen. Extrapolation extends the last constant polynomial at the end points on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\ndir: indicates which value should be used for interpolation (:left or :right).\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.QuadraticSpline","page":"Manual","title":"DataInterpolations.QuadraticSpline","text":"QuadraticSpline(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a spline interpolation using piecewise quadratic polynomials between each pair of data points. Its first derivative is also continuous. Extrapolation extends the last quadratic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.CubicSpline","page":"Manual","title":"DataInterpolations.CubicSpline","text":"CubicSpline(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a spline interpolation using piecewise cubic polynomials between each pair of data points. Its first and second derivative is also continuous. Second derivative on both ends are zero, which are also called \"natural\" boundary conditions. Extrapolation extends the last cubic polynomial on each side.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.BSplineInterpolation","page":"Manual","title":"DataInterpolations.BSplineInterpolation","text":"BSplineInterpolation(u, t, d, pVecType, knotVecType; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a curve defined by the linear combination of n basis functions of degree d where n is the number of data points. For more information, refer https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve.html. Extrapolation is a constant polynomial of the end points on each side.\n\nArguments\n\nu: data points.\nt: time points.\nd: degree of the piecewise polynomial.\npVecType: symbol to parameters vector, :Uniform for uniform spaced parameters and :ArcLen for parameters generated by chord length method.\nknotVecType: symbol to knot vector, :Uniform for uniform knot vector, :Average for average spaced knot vector.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nassume_linear_t: boolean value to specify a faster index lookup behavior for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.BSplineApprox","page":"Manual","title":"DataInterpolations.BSplineApprox","text":"BSplineApprox(u, t, d, h, pVecType, knotVecType; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a regression based B-spline. The argument choices are the same as the BSplineInterpolation, with the additional parameter h < length(t) which is the number of control points to use, with smaller h indicating more smoothing. For more information, refer http://www.cad.zju.edu.cn/home/zhx/GM/009/00-bsia.pdf. Extrapolation is a constant polynomial of the end points on each side.\n\nArguments\n\nu: data points.\nt: time points.\nd: degree of the piecewise polynomial.\nh: number of control points to use.\npVecType: symbol to parameters vector, :Uniform for uniform spaced parameters and :ArcLen for parameters generated by chord length method.\nknotVecType: symbol to knot vector, :Uniform for uniform knot vector, :Average for average spaced knot vector.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.CubicHermiteSpline","page":"Manual","title":"DataInterpolations.CubicHermiteSpline","text":"CubicHermiteSpline(du, u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None, cache_parameters = false)\n\nIt is a Cubic Hermite interpolation, which is a piece-wise third degree polynomial such that the value and the first derivative are equal to given values in the data points.\n\nArguments\n\ndu: the derivative at the data points.\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DataInterpolations.PCHIPInterpolation","page":"Manual","title":"DataInterpolations.PCHIPInterpolation","text":"PCHIPInterpolation(u, t; extrapolation::ExtrapolationType.T = ExtrapolationType.None, extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a PCHIP Interpolation, which is a type of CubicHermiteSpline where the derivative values du are derived from the input data in such a way that the interpolation never overshoots the data. See here, section 3.4 for more details.\n\nArguments\n\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DataInterpolations.QuinticHermiteSpline","page":"Manual","title":"DataInterpolations.QuinticHermiteSpline","text":"QuinticHermiteSpline(ddu, du, u, t; extrapolation_left::ExtrapolationType.T = ExtrapolationType.None,\n    extrapolation_right::ExtrapolationType.T = ExtrapolationType.None)\n\nIt is a Quintic Hermite interpolation, which is a piece-wise fifth degree polynomial such that the value and the first and second derivative are equal to given values in the data points.\n\nArguments\n\nddu: the second derivative at the data points.\ndu: the derivative at the data points.\nu: data points.\nt: time points.\n\nKeyword Arguments\n\nextrapolation: The extrapolation type applied left and right of the data. Possible options are ExtrapolationType.None (default), ExtrapolationType.Constant, ExtrapolationType.Linear ExtrapolationType.Extension, ExtrapolationType.Periodic and ExtrapolationType.Reflective.\nextrapolation_left: The extrapolation type applied left of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\nextrapolation_right: The extrapolation type applied right of the data. See extrapolation for the possible options. This keyword is ignored if extrapolation != Extrapolation.none.\ncache_parameters: precompute parameters at initialization for faster interpolation computations. Note: if activated, u and t should not be modified. Defaults to false.\nassume_linear_t: boolean value to specify a faster index lookup behaviour for evenly-distributed abscissae. Alternatively, a numerical threshold may be specified for a test based on the normalized standard deviation of the difference with respect to the straight line (see looks_linear). Defaults to 1e-2.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Utility-Functions","page":"Manual","title":"Utility Functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"DataInterpolations.looks_linear","category":"page"},{"location":"manual/#DataInterpolations.looks_linear","page":"Manual","title":"DataInterpolations.looks_linear","text":"looks_linear(t; threshold = 1e-2)\n\nDetermine if the abscissae t are regularly distributed, taking the standard deviation of the difference between the array of abscissae with respect to the straight line linking its first and last elements, normalized by the range of t. If this standard deviation is below the given threshold, the vector looks linear (return true). Internal function - interface may change.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Interpolation-using-different-methods","page":"Interpolation methods","title":"Interpolation using different methods","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"We will use the following data to demonstrate interpolation methods.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"using DataInterpolations, Plots\ngr() # hide\n\n# Dependent variable\nu = [14.7, 11.51, 10.41, 14.95, 12.24, 11.22]\n\n# Independent variable\nt = [0.0, 62.25, 109.66, 162.66, 205.8, 252.3]","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"For each method, we will show how to perform the fit and use the plot recipe to show the fitting curve.","category":"page"},{"location":"methods/#Linear-Interpolation","page":"Interpolation methods","title":"Linear Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is a linear interpolation between the ends points of the interval of input data points.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = LinearInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Quadratic-Interpolation","page":"Interpolation methods","title":"Quadratic Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This function fits a parabola passing through the two nearest points from the input data point as well as the next-closest point on the right or left, depending on whether the forward- or backward-looking mode is selected (default mode is forward-looking). It is continuous and piecewise differentiable.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = QuadraticInterpolation(u, t) # same as QuadraticInterpolation(u,t,:Forward)\n# alternatively: A = QuadraticInterpolation(u,t,:Backward)\nplot(A)","category":"page"},{"location":"methods/#Lagrange-Interpolation","page":"Interpolation methods","title":"Lagrange Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"It fits a polynomial of degree d (=length(t)-1), and is thus a continuously differentiable function.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = LagrangeInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Akima-Interpolation","page":"Interpolation methods","title":"Akima Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This function fits piecewise cubic polynomials which forms a continuously differentiable function. This differs from Cubic Spline as coefficients are computed using only neighbouring points and hence the fit looks more natural.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = AkimaInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Constant-Interpolation","page":"Interpolation methods","title":"Constant Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This function is constant between data points. By default, it takes the value at the left end of the interval. One can change that behavior by passing the keyword argument dir = :right.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = ConstantInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Or using the right endpoints:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = ConstantInterpolation(u, t, dir = :right)\nplot(A)","category":"page"},{"location":"methods/#Quadratic-Spline","page":"Interpolation methods","title":"Quadratic Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the quadratic spline. It is a continuously differentiable interpolation which hits each of the data points exactly. Splines are a local interpolation method, meaning that the curve in a given spot is only affected by the points nearest to it.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = QuadraticSpline(u, t)\nplot(A)","category":"page"},{"location":"methods/#Cubic-Spline","page":"Interpolation methods","title":"Cubic Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the cubic spline. It is a continuously twice differentiable interpolation which hits each of the data points exactly.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = CubicSpline(u, t)\nplot(A)","category":"page"},{"location":"methods/#B-Splines","page":"Interpolation methods","title":"B-Splines","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is an interpolating B-spline. B-splines are a global method, meaning that every data point is taken into account for each point of the curve. The interpolating B-spline is the version which hits each of the points. This method is described in more detail here. Let's plot a cubic B-spline (3rd order). Since the data points are not close to uniformly spaced, we will use the :ArcLen and :Average choices:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = BSplineInterpolation(u, t, 3, :ArcLen, :Average)\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"The approximating B-spline is a smoothed version of the B-spline. It again is a global method. In this case, we need to give a number of control points length(t)>h and this method fits a B-spline through the control points which is a least square approximation. This has a natural effect of smoothing the data. For example, if we use 4 control points, we get the result:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = BSplineApprox(u, t, 3, 4, :ArcLen, :Average)\nplot(A)","category":"page"},{"location":"methods/#Cubic-Hermite-Spline","page":"Interpolation methods","title":"Cubic Hermite Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the cubic (third order) Hermite interpolation. It matches the values and first order derivatives in the data points exactly.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"du = [-0.047, -0.058, 0.054, 0.012, -0.068, 0.0011]\nA = CubicHermiteSpline(du, u, t)\nplot(A)","category":"page"},{"location":"methods/#PCHIP-Interpolation","page":"Interpolation methods","title":"PCHIP Interpolation","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is a type of CubicHermiteSpline where the derivative values du are derived from the input data in such a way that the interpolation never overshoots the data.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = PCHIPInterpolation(u, t)\nplot(A)","category":"page"},{"location":"methods/#Quintic-Hermite-Spline","page":"Interpolation methods","title":"Quintic Hermite Spline","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"This is the quintic (fifth order) Hermite interpolation. It matches the values and first and second order derivatives in the data points exactly.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"ddu = [0.0, -0.00033, 0.0051, -0.0067, 0.0029, 0.0]\ndu = [-0.047, -0.058, 0.054, 0.012, -0.068, 0.0011]\nA = QuinticHermiteSpline(ddu, du, u, t)\nplot(A)","category":"page"},{"location":"methods/#Regularization-Smoothing","page":"Interpolation methods","title":"Regularization Smoothing","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Smoothing by regularization (a.k.a. ridge regression) finds a function hatu that minimizes the objective function:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Q(hatu) = int_t_1^t_N hatu(t) - u(t)^2 mathrmdt + lambda int_hatt_1^hatt_N hatu^(d)(hatt)^2 mathrmd hatt","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"where (d) denotes derivative order and lambda is the regularization (smoothing) parameter. The integrals are evaluated numerically at the set of t values for the first term and hatt values for the second term (equal to t if not provided). Regularization smoothing is a global method that creates a smooth curve directly. See Stickel (2010) Comput. Chem. Eng. 34:467 for details. The implementation in this package uses cubic splines to interpolate between the smoothed points after they are determined.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"using RegularizationTools\nd = 2\nλ = 1e3\nA = RegularizationSmooth(u, t, d; λ = λ, alg = :fixed)\nû = A.û\n# interpolate using the smoothed values\nN = 200\ntitp = collect(range(minimum(t), maximum(t), length = N))\nuitp = A.(titp)\nlw = 1.5\nscatter(t, u, label = \"data\")\nscatter!(t, û, marker = :square, label = \"smoothed data\")\nplot!(titp, uitp, lw = lw, label = \"smoothed interpolation\")","category":"page"},{"location":"methods/#Dense-Data-Demonstration","page":"Interpolation methods","title":"Dense Data Demonstration","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Some methods are better suited for dense data. Let's generate such data to demonstrate these methods.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"import StableRNGs: StableRNG\nrng = StableRNG(318)\nt = sort(10 .* rand(rng, 100))\nu = sin.(t) .+ 0.5 * randn(rng, 100);","category":"page"},{"location":"methods/#Regularization-Smoothing-2","page":"Interpolation methods","title":"Regularization Smoothing","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Although smoothing by regularization can be used to interpolate sparse data as shown above, it is especially useful for dense as well as scattered data (unequally spaced, unordered, and/or repeat-valued). Generalized cross validation (GCV) or so-called L-curve methods can be used to determine an \"optimal\" value for the smoothing parameter. In this example, we perform smoothing in two ways. In the first, we find smooth values at the original t values and then interpolate. In the second, we perform the smoothing for the interpolant hatt values directly. GCV is used to determine the regularization parameter for both cases.","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"d = 4\nA = RegularizationSmooth(u, t, d; alg = :gcv_svd)\nû = A.û\nN = 200\ntitp = collect(range(minimum(t), maximum(t), length = N))\nuitp = A.(titp)\nAm = RegularizationSmooth(u, t, titp, d; alg = :gcv_svd)\nûm = Am.û\nscatter(t, u, label = \"simulated data\", legend = :top)\nscatter!(t, û, marker = (:square, 4), label = \"smoothed data\")\nplot!(titp, uitp, lw = lw, label = \"smoothed interpolation\")\nplot!(titp, ûm, lw = lw, linestyle = :dash, label = \"smoothed, more points\")","category":"page"},{"location":"methods/#Curve-Fits","page":"Interpolation methods","title":"Curve Fits","text":"","category":"section"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A curve fit works with both dense and sparse data. We will demonstrate the curve fit on the dense data since we generated it based on sin(t), so this is the curve we want to fit through it. To do so, let's define a similar function with parameters. Let's choose the form:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"m(t, p) = @. p[1] * sin(p[2] * t) + p[3] * cos(p[4] * t)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Notice that this is a function on the whole array of t and expects an array for the predicted u out. This choice of m is based on the assumption that our function is of the form p1*sin(p2*t)+p3*cos(p4*t). We want to find the p to match our data. Let's start with the guess of every p being zero, that is p=ones(4). Then we would fit this curve using:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"using Optim\nA = Curvefit(u, t, m, ones(4), LBFGS())\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"We can check what the fitted parameters are via:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A.pmin","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"Notice that it essentially made p3=0 with p1=p2=1, meaning it approximately found sin(t)! But note that the ability to fit is dependent on the initial parameters. For example, with p=zeros(4) as the initial parameters, the fit is not good:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A = Curvefit(u, t, m, zeros(4), LBFGS())\nplot(A)","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"And the parameters show the issue:","category":"page"},{"location":"methods/","page":"Interpolation methods","title":"Interpolation methods","text":"A.pmin","category":"page"},{"location":"#DataInterpolations.jl","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"DataInterpolations.jl is a library for performing interpolations of one-dimensional data. Interpolations are a very important component of many modeling workflows. Often, sampled or measured inputs need to be transformed into continuous functions or smooth curves for simulation purposes. In many scientific machine learning workflows, interpolating data is essential to learn continuous models. DataInterpolations.jl can be used for facilitating these types of workflows. By \"data interpolations\" we mean techniques for interpolating possibly noisy data, and thus some methods are mixtures of regressions with interpolations (i.e. do not hit the data points exactly, smoothing out the lines).","category":"page"},{"location":"#Installation","page":"DataInterpolations.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"To install DataInterpolations.jl, use the Julia package manager:","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using Pkg\nPkg.add(\"DataInterpolations\")","category":"page"},{"location":"#Available-Interpolations","page":"DataInterpolations.jl","title":"Available Interpolations","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"In all cases, u an AbstractVector of values and t is an AbstractVector of timepoints corresponding to (u,t) pairs.","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"ConstantInterpolation(u,t) - A piecewise constant interpolation.\nLinearInterpolation(u,t) - A linear interpolation.\nQuadraticInterpolation(u,t) - A quadratic interpolation.\nLagrangeInterpolation(u,t,n) - A Lagrange interpolation of order n.\nQuadraticSpline(u,t) - A quadratic spline interpolation.\nCubicSpline(u,t) - A cubic spline interpolation.\nAkimaInterpolation(u, t) - Akima spline interpolation provides a smoothing effect and is computationally efficient.\nBSplineInterpolation(u,t,d,pVec,knotVec) - An interpolation B-spline. This is a B-spline that hits each of the data points. The argument choices are:\nd - degree of B-spline\npVec - Symbol to Parameters Vector, pVec = :Uniform for uniformly spaced parameters, and pVec = :ArcLen for parameters generated by the chord length method.\nknotVec - Symbol to Knot Vector, knotVec = :Uniform for uniform knot vector, knotVec = :Average for average spaced knot vector.\nBSplineApprox(u,t,d,h,pVec,knotVec) - A regression B-spline which smooths the fitting curve. The argument choices are the same as the BSplineInterpolation, with the additional parameter h<length(t) which is the number of control points to use, with smaller h indicating more smoothing.\nCubicHermiteSpline(du, u, t) - A third order Hermite interpolation, which matches the values and first (du) order derivatives in the data points exactly.\nPCHIPInterpolation(u, t) - a type of CubicHermiteSpline where the derivative values du are derived from the input data in such a way that the interpolation never overshoots the data.\nQuinticHermiteSpline(ddu, du, u, t) - a fifth order Hermite interpolation, which matches the values and first (du) and second (ddu) order derivatives in the data points exactly.","category":"page"},{"location":"#Extension-Methods","page":"DataInterpolations.jl","title":"Extension Methods","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"The following methods require extra dependencies and will be loaded as package extensions.","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"Curvefit(u,t,m,p,alg) - An interpolation which is done by fitting a user-given functional form m(t,p) where p is the vector of parameters. The user's input p is an initial value for a least-squares fitting, alg is the algorithm choice to use to optimize the cost function (sum of squared deviations) via Optim.jl and optimal ps are used in the interpolation. Requires using Optim.\nRegularizationSmooth(u,t,d;λ,alg) - A regularization algorithm (ridge regression) which is done by minimizing an objective function (l2 loss + derivatives of order d) integrated in the time span. It is a global method which creates a smooth curve. Requires using RegularizationTools.","category":"page"},{"location":"#Plotting","page":"DataInterpolations.jl","title":"Plotting","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"DataInterpolations.jl is tied into the Plots.jl ecosystem, by way of RecipesBase. Any interpolation can be plotted using the plot command (or any other), since they have type recipes associated with them.","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"For convenience, and to allow keyword arguments to propagate properly, DataInterpolations.jl also defines several series types, corresponding to different interpolations.","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"The series types defined are:","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":":linear_interp\n:quadratic_interp\n:lagrange_interp\n:quadratic_spline\n:cubic_spline\n:akima_interp\n:bspline_interp\n:bspline_approx\n:cubic_hermite_spline\n:pchip_interp\n:quintic_hermite_spline","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"By and large, these accept the same keywords as their function counterparts.","category":"page"},{"location":"#Citing","page":"DataInterpolations.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"If you use this software in your work, please cite:","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"@article{Bhagavan2024,\n  doi = {10.21105/joss.06917},\n  url = {https://doi.org/10.21105/joss.06917},\n  year = {2024},\n  publisher = {The Open Journal},\n  volume = {9},\n  number = {101},\n  pages = {6917},\n  author = {Sathvik Bhagavan and Bart de Koning and Shubham Maddhashiya and Christopher Rackauckas},\n  title = {DataInterpolations.jl: Fast Interpolations of 1D data},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"#Contributing","page":"DataInterpolations.jl","title":"Contributing","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"DataInterpolations.jl","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"</details>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"</details>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"</details>","category":"page"},{"location":"","page":"DataInterpolations.jl","title":"DataInterpolations.jl","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
