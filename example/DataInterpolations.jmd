# DataInterpolations.jl

This library is meant for interpolating one dimensional data by methods which
both hit every point exactly or smooth the data into an approximate fitting
curve. The library contains the following interpolation methods:

-  Linear Interpolation
-  Quadratic Interpolation
-  Lagrange Interpolation
-  Zero Spline
-  Quadratic Spline
-  Cubic Spline
-  BSpline Global Curve Interpolation
-  BSpline Global Curve Approximation
-  Curve fitting

## Demonstration

We will use the following data to demonstrate interpolation methods.
```julia
using DataInterpolations, Plots
gr()
# Dependent variable
u = [14.7, 11.51, 10.41, 14.95, 12.24, 11.22]
# Independent variable
t = [0.0, 62.25, 109.66, 162.66, 205.8, 252.3]
```

For each method, we will show how to perform the fit and use the plot recipe
to show the fitting curve.

### Linear Interpolation

This is a linear interpolation between ends points of interval of input data point.

```julia
A = LinearInterpolation(u,t)
scatter(t, u, label="input data")
plot!(A)
```

### Quadratic Interpolation

This function fits a parabola passing through the two nearest points from the input
data point as well as the next-closest point in the right or the left, depending on
whether the forward- or backward-looking mode is selected (default mode is 
forward-looking). It is continuous and piecewise differentiable.

```julia
A = QuadraticInterpolation(u,t) # same as QuadraticInterpolation(u,t,:Forward)
# alternatively: A = QuadraticInterpolation(u,t,:Backward)
scatter(t, u, label="input data")
plot!(A)
```

### Lagrange Interpolation

It fits polynomial of degree d (=length(t)-1), and is thuse a continuously
differentiable function.

```julia
A = LagrangeInterpolation(u,t)
scatter(t, u, label="input data")
plot!(A)
```

### Constant Interpolation
This function is constant between data points. By default
it takes value at left end of the interval. One can change that behavior by
passing the keyword argument `dir = :right`.

```julia
A = ConstantInterpolation(u,t)
scatter(t, u, label="input data")
plot!(A)
```

Or using the right endpoints:

```julia
A = ConstantInterpolation(u, t, dir=:right)
scatter(t, u, label="input data")
plot!(A)
```

### Quadratic Spline
This is the quadratic spline. It is a continuously differentiable interpolation
which hits each of the data points exactly. Splines are a local interpolation
method, meaning that the curve in a given spot is only affected by the points
nearest to it. It is explained in more detail at
https://www.math.uh.edu/~jingqiu/math4364/spline.pdf .

```julia
A = QuadraticSpline(u,t)
scatter(t, u, label="input data")
plot!(A)
```

### Cubic Spline
This is the cubic spline. It is a continuously twice differentiable interpolation
which hits each of the data points exactly. It is explained in more detail at
https://www.math.uh.edu/~jingqiu/math4364/spline.pdf .

```julia
A = CubicSpline(u,t)
scatter(t, u, label="input data")
plot!(A)
```

### B-Splines

This is an interpolating B-spline. B-splines are a global method, meaning
that every data point is taken into account for each point of the curve.
The interpolating B-spline is the version which hits each of the points. This
method is described in more detail at
https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/INT-APP/CURVE-INT-global.html .
Let's plot a cubic B-spline (3rd order). Since the data points are not close to
uniformly spaced, we will use the `:ArcLen` and `:Average` choices:

```julia
A = BSplineInterpolation(u, t, 3, :ArcLen, :Average)
scatter(t, u, label="input data")
plot!(A)
```

The approximating B-spline is a smoothed version of the B-spline. It again is
a global method. In this case, we need to give a number of control points
`length(t)>h` and this method fits a B-spline through the control points which
is a least square approximation. This has a natural effect of smoothing the
data. For example, if we use 4 control points, we get the result:

```julia
A = BSplineApprox(u, t, 3, 4, :ArcLen, :Average)
scatter(t, u, label="input data")
plot!(A)
```

## Dense Data Demonstration

Some methods are better suited for dense data. Let's generate such data to
demonstrate these methods.

```julia
import StableRNGs: StableRNG
rng = StableRNG(318)
t = sort(10 .* rand(rng, 100))
u = sin.(t) .+ 0.5 * randn(rng, 100)
```

### Curve Fits

A curve fit works with both dense and sparse data. We will demonstrate the curve
fit on the dense data since we generated it based on `sin(t)`, so this is the
curve we want to fit through it. Do do so, let's define a similar function
with parameters. Let's choose the form:

```julia
m(t,p) = @. p[1]*sin(p[2]*t) + p[3]*cos(p[4]*t)
```

Notice that this is a function on the whole array of `t` and expects an array
for the predicted `u` out. This choice of `m` is the assumption that our
function is of the form `p1*sin(p2*t)+p3*cos(p4*t)`. We want to find the `p` to
match our data. Let's start with the guess of every `p` being zero, that is
`p=ones(4)`. Then we would fit this curve using:

```julia
A = Curvefit(u, t, m, ones(4), LBFGS())
scatter(t, u, label="points", legend=:bottomright)
plot!(A)
```

We can check what the fitted parameters are via:

```julia
A.pmin
```

Notice that it essentially made `p3=0` with `p1=p2=1`, meaning it approximately
found `sin(t)`! But note that the ability to fit is dependent on the initial
parameters. For example, with `p=zeros(4)` as the initial parameters the fit
is not good:

```julia
A = Curvefit(u, t, m, zeros(4), LBFGS())
scatter(t,u,label="points",legend=:bottomright)
plot!(A)
```

And the parameters show the issue:

```julia
A.pmin
```