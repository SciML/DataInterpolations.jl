<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · DataInterpolations.jl</title><meta name="title" content="Methods · DataInterpolations.jl"/><meta property="og:title" content="Methods · DataInterpolations.jl"/><meta property="twitter:title" content="Methods · DataInterpolations.jl"/><meta name="description" content="Documentation for DataInterpolations.jl."/><meta property="og:description" content="Documentation for DataInterpolations.jl."/><meta property="twitter:description" content="Documentation for DataInterpolations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DataInterpolations/stable/methods/"/><meta property="twitter:url" content="https://docs.sciml.ai/DataInterpolations/stable/methods/"/><link rel="canonical" href="https://docs.sciml.ai/DataInterpolations/stable/methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DataInterpolations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataInterpolations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">DataInterpolations.jl</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Linear-Interpolation"><span>Linear Interpolation</span></a></li><li><a class="tocitem" href="#Quadratic-Interpolation"><span>Quadratic Interpolation</span></a></li><li><a class="tocitem" href="#Lagrange-Interpolation"><span>Lagrange Interpolation</span></a></li><li><a class="tocitem" href="#Akima-Interpolation"><span>Akima Interpolation</span></a></li><li><a class="tocitem" href="#Constant-Interpolation"><span>Constant Interpolation</span></a></li><li><a class="tocitem" href="#Quadratic-Spline"><span>Quadratic Spline</span></a></li><li><a class="tocitem" href="#Cubic-Spline"><span>Cubic Spline</span></a></li><li><a class="tocitem" href="#B-Splines"><span>B-Splines</span></a></li><li><a class="tocitem" href="#Cubic-Hermite-Spline"><span>Cubic Hermite Spline</span></a></li><li><a class="tocitem" href="#PCHIP-Interpolation"><span>PCHIP Interpolation</span></a></li><li><a class="tocitem" href="#Quintic-Hermite-Spline"><span>Quintic Hermite Spline</span></a></li><li><a class="tocitem" href="#Regularization-Smoothing"><span>Regularization Smoothing</span></a></li><li><a class="tocitem" href="#Dense-Data-Demonstration"><span>Dense Data Demonstration</span></a></li><li><a class="tocitem" href="#Regularization-Smoothing-2"><span>Regularization Smoothing</span></a></li><li><a class="tocitem" href="#Curve-Fits"><span>Curve Fits</span></a></li></ul></li><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../inverting_integrals/">Inverting Integrals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DataInterpolations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DataInterpolations.jl/blob/master/docs/src/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolation-using-different-methods"><a class="docs-heading-anchor" href="#Interpolation-using-different-methods">Interpolation using different methods</a><a id="Interpolation-using-different-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-using-different-methods" title="Permalink"></a></h1><p>We will use the following data to demonstrate interpolation methods.</p><pre><code class="language-julia hljs">using DataInterpolations, Plots

# Dependent variable
u = [14.7, 11.51, 10.41, 14.95, 12.24, 11.22]

# Independent variable
t = [0.0, 62.25, 109.66, 162.66, 205.8, 252.3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Float64}:
   0.0
  62.25
 109.66
 162.66
 205.8
 252.3</code></pre><p>For each method, we will show how to perform the fit and use the plot recipe to show the fitting curve.</p><h2 id="Linear-Interpolation"><a class="docs-heading-anchor" href="#Linear-Interpolation">Linear Interpolation</a><a id="Linear-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Interpolation" title="Permalink"></a></h2><p>This is a linear interpolation between the ends points of the interval of input data points.</p><pre><code class="language-julia hljs">A = LinearInterpolation(u, t)
plot(A)</code></pre><img src="76db92e8.svg" alt="Example block output"/><h2 id="Quadratic-Interpolation"><a class="docs-heading-anchor" href="#Quadratic-Interpolation">Quadratic Interpolation</a><a id="Quadratic-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Interpolation" title="Permalink"></a></h2><p>This function fits a parabola passing through the two nearest points from the input data point as well as the next-closest point on the right or left, depending on whether the forward- or backward-looking mode is selected (default mode is forward-looking). It is continuous and piecewise differentiable.</p><pre><code class="language-julia hljs">A = QuadraticInterpolation(u, t) # same as QuadraticInterpolation(u,t,:Forward)
# alternatively: A = QuadraticInterpolation(u,t,:Backward)
plot(A)</code></pre><img src="4c5fc964.svg" alt="Example block output"/><h2 id="Lagrange-Interpolation"><a class="docs-heading-anchor" href="#Lagrange-Interpolation">Lagrange Interpolation</a><a id="Lagrange-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-Interpolation" title="Permalink"></a></h2><p>It fits a polynomial of degree d (=length(t)-1), and is thus a continuously differentiable function.</p><pre><code class="language-julia hljs">A = LagrangeInterpolation(u, t)
plot(A)</code></pre><img src="2875f115.svg" alt="Example block output"/><h2 id="Akima-Interpolation"><a class="docs-heading-anchor" href="#Akima-Interpolation">Akima Interpolation</a><a id="Akima-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Akima-Interpolation" title="Permalink"></a></h2><p>This function fits piecewise cubic polynomials which forms a continuously differentiable function. This differs from Cubic Spline as coefficients are computed using only neighbouring points and hence the fit looks more natural.</p><pre><code class="language-julia hljs">A = AkimaInterpolation(u, t)
plot(A)</code></pre><img src="fd56edfb.svg" alt="Example block output"/><h2 id="Constant-Interpolation"><a class="docs-heading-anchor" href="#Constant-Interpolation">Constant Interpolation</a><a id="Constant-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Constant-Interpolation" title="Permalink"></a></h2><p>This function is constant between data points. By default, it takes the value at the left end of the interval. One can change that behavior by passing the keyword argument <code>dir = :right</code>.</p><pre><code class="language-julia hljs">A = ConstantInterpolation(u, t)
plot(A)</code></pre><img src="da70976d.svg" alt="Example block output"/><p>Or using the right endpoints:</p><pre><code class="language-julia hljs">A = ConstantInterpolation(u, t, dir = :right)
plot(A)</code></pre><img src="4284600c.svg" alt="Example block output"/><h2 id="Quadratic-Spline"><a class="docs-heading-anchor" href="#Quadratic-Spline">Quadratic Spline</a><a id="Quadratic-Spline-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Spline" title="Permalink"></a></h2><p>This is the quadratic spline. It is a continuously differentiable interpolation which hits each of the data points exactly. Splines are a local interpolation method, meaning that the curve in a given spot is only affected by the points nearest to it.</p><pre><code class="language-julia hljs">A = QuadraticSpline(u, t)
plot(A)</code></pre><img src="a3a1d176.svg" alt="Example block output"/><h2 id="Cubic-Spline"><a class="docs-heading-anchor" href="#Cubic-Spline">Cubic Spline</a><a id="Cubic-Spline-1"></a><a class="docs-heading-anchor-permalink" href="#Cubic-Spline" title="Permalink"></a></h2><p>This is the cubic spline. It is a continuously twice differentiable interpolation which hits each of the data points exactly.</p><pre><code class="language-julia hljs">A = CubicSpline(u, t)
plot(A)</code></pre><img src="85ebc2f7.svg" alt="Example block output"/><h2 id="B-Splines"><a class="docs-heading-anchor" href="#B-Splines">B-Splines</a><a id="B-Splines-1"></a><a class="docs-heading-anchor-permalink" href="#B-Splines" title="Permalink"></a></h2><p>This is an interpolating B-spline. B-splines are a global method, meaning that every data point is taken into account for each point of the curve. The interpolating B-spline is the version which hits each of the points. This method is described in more detail <a href="https://pages.mtu.edu/%7Eshene/COURSES/cs3621/NOTES/INT-APP/CURVE-INT-global.html">here</a>. Let&#39;s plot a cubic B-spline (3rd order). Since the data points are not close to uniformly spaced, we will use the <code>:ArcLen</code> and <code>:Average</code> choices:</p><pre><code class="language-julia hljs">A = BSplineInterpolation(u, t, 3, :ArcLen, :Average)
plot(A)</code></pre><img src="5121807e.svg" alt="Example block output"/><p>The approximating B-spline is a smoothed version of the B-spline. It again is a global method. In this case, we need to give a number of control points <code>length(t)&gt;h</code> and this method fits a B-spline through the control points which is a least square approximation. This has a natural effect of smoothing the data. For example, if we use 4 control points, we get the result:</p><pre><code class="language-julia hljs">A = BSplineApprox(u, t, 3, 4, :ArcLen, :Average)
plot(A)</code></pre><img src="e9a18f04.svg" alt="Example block output"/><h2 id="Cubic-Hermite-Spline"><a class="docs-heading-anchor" href="#Cubic-Hermite-Spline">Cubic Hermite Spline</a><a id="Cubic-Hermite-Spline-1"></a><a class="docs-heading-anchor-permalink" href="#Cubic-Hermite-Spline" title="Permalink"></a></h2><p>This is the cubic (third order) Hermite interpolation. It matches the values and first order derivatives in the data points exactly.</p><pre><code class="language-julia hljs">du = [-0.047, -0.058, 0.054, 0.012, -0.068, 0.0011]
A = CubicHermiteSpline(du, u, t)
plot(A)</code></pre><img src="c462b236.svg" alt="Example block output"/><h2 id="PCHIP-Interpolation"><a class="docs-heading-anchor" href="#PCHIP-Interpolation">PCHIP Interpolation</a><a id="PCHIP-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#PCHIP-Interpolation" title="Permalink"></a></h2><p>This is a type of <code>CubicHermiteSpline</code> where the derivative values <code>du</code> are derived from the input data in such a way that the interpolation never overshoots the data.</p><pre><code class="language-julia hljs">A = PCHIPInterpolation(u, t)
plot(A)</code></pre><img src="80fae355.svg" alt="Example block output"/><h2 id="Quintic-Hermite-Spline"><a class="docs-heading-anchor" href="#Quintic-Hermite-Spline">Quintic Hermite Spline</a><a id="Quintic-Hermite-Spline-1"></a><a class="docs-heading-anchor-permalink" href="#Quintic-Hermite-Spline" title="Permalink"></a></h2><p>This is the quintic (fifth order) Hermite interpolation. It matches the values and first and second order derivatives in the data points exactly.</p><pre><code class="language-julia hljs">ddu = [0.0, -0.00033, 0.0051, -0.0067, 0.0029, 0.0]
du = [-0.047, -0.058, 0.054, 0.012, -0.068, 0.0011]
A = QuinticHermiteSpline(ddu, du, u, t)
plot(A)</code></pre><img src="29a04486.svg" alt="Example block output"/><h2 id="Regularization-Smoothing"><a class="docs-heading-anchor" href="#Regularization-Smoothing">Regularization Smoothing</a><a id="Regularization-Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization-Smoothing" title="Permalink"></a></h2><p>Smoothing by regularization (a.k.a. ridge regression) finds a function <span>$\hat{u}$</span> that minimizes the objective function:</p><p><span>$Q(\hat{u}) = \int_{t_1}^{t_N} |\hat{u}(t) - u(t)|^2 \mathrm{d}t + \lambda \int_{\hat{t}_1}^{\hat{t}_N} |\hat{u}^{(d)}(\hat{t})|^2 \mathrm{d} \hat{t}$</span></p><p>where <span>$(d)$</span> denotes derivative order and <span>$\lambda$</span> is the regularization (smoothing) parameter. The integrals are evaluated numerically at the set of <span>$t$</span> values for the first term and <span>$\hat{t}$</span> values for the second term (equal to <span>$t$</span> if not provided). Regularization smoothing is a global method that creates a smooth curve directly. See <a href="http://dx.doi.org/10.1016/j.compchemeng.2009.10.007">Stickel (2010) Comput. Chem. Eng. 34:467</a> for details. The implementation in this package uses cubic splines to interpolate between the smoothed points after they are determined.</p><pre><code class="language-julia hljs">using RegularizationTools
d = 2
λ = 1e3
A = RegularizationSmooth(u, t, d; λ = λ, alg = :fixed)
û = A.û
# interpolate using the smoothed values
N = 200
titp = collect(range(minimum(t), maximum(t), length = N))
uitp = A.(titp)
lw = 1.5
scatter(t, u, label = &quot;data&quot;)
scatter!(t, û, marker = :square, label = &quot;smoothed data&quot;)
plot!(titp, uitp, lw = lw, label = &quot;smoothed interpolation&quot;)</code></pre><img src="1c840602.svg" alt="Example block output"/><h2 id="Dense-Data-Demonstration"><a class="docs-heading-anchor" href="#Dense-Data-Demonstration">Dense Data Demonstration</a><a id="Dense-Data-Demonstration-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-Data-Demonstration" title="Permalink"></a></h2><p>Some methods are better suited for dense data. Let&#39;s generate such data to demonstrate these methods.</p><pre><code class="language-julia hljs">import StableRNGs: StableRNG
rng = StableRNG(318)
t = sort(10 .* rand(rng, 100))
u = sin.(t) .+ 0.5 * randn(rng, 100);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{Float64}:
 -0.4891563556934994
 -0.7411337336203204
  0.303260759772529
 -0.03721116720925663
 -0.5073147206014983
  0.1956851914978695
  0.5717256362165741
  0.29209309353794644
  0.6444380583968424
  0.5907863715716408
  ⋮
  1.4566016140618308
  1.016810621114802
  0.32542000692979595
  1.1323247210598848
 -0.0495435623347093
  0.1762559989623056
 -0.5319640155153034
 -0.9932887141154423
 -1.2766512199488596</code></pre><h2 id="Regularization-Smoothing-2"><a class="docs-heading-anchor" href="#Regularization-Smoothing-2">Regularization Smoothing</a><a class="docs-heading-anchor-permalink" href="#Regularization-Smoothing-2" title="Permalink"></a></h2><p>Although smoothing by regularization can be used to interpolate sparse data as shown above, it is especially useful for dense as well as scattered data (unequally spaced, unordered, and/or repeat-valued). Generalized cross validation (GCV) or so-called L-curve methods can be used to determine an &quot;optimal&quot; value for the smoothing parameter. In this example, we perform smoothing in two ways. In the first, we find smooth values at the original <span>$t$</span> values and then interpolate. In the second, we perform the smoothing for the interpolant <span>$\hat{t}$</span> values directly. GCV is used to determine the regularization parameter for both cases.</p><pre><code class="language-julia hljs">d = 4
A = RegularizationSmooth(u, t, d; alg = :gcv_svd)
û = A.û
N = 200
titp = collect(range(minimum(t), maximum(t), length = N))
uitp = A.(titp)
Am = RegularizationSmooth(u, t, titp, d; alg = :gcv_svd)
ûm = Am.û
scatter(t, u, label = &quot;simulated data&quot;, legend = :top)
scatter!(t, û, marker = (:square, 4), label = &quot;smoothed data&quot;)
plot!(titp, uitp, lw = lw, label = &quot;smoothed interpolation&quot;)
plot!(titp, ûm, lw = lw, linestyle = :dash, label = &quot;smoothed, more points&quot;)</code></pre><img src="d70bfdff.svg" alt="Example block output"/><h2 id="Curve-Fits"><a class="docs-heading-anchor" href="#Curve-Fits">Curve Fits</a><a id="Curve-Fits-1"></a><a class="docs-heading-anchor-permalink" href="#Curve-Fits" title="Permalink"></a></h2><p>A curve fit works with both dense and sparse data. We will demonstrate the curve fit on the dense data since we generated it based on <code>sin(t)</code>, so this is the curve we want to fit through it. To do so, let&#39;s define a similar function with parameters. Let&#39;s choose the form:</p><pre><code class="language-julia hljs">m(t, p) = @. p[1] * sin(p[2] * t) + p[3] * cos(p[4] * t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">m (generic function with 1 method)</code></pre><p>Notice that this is a function on the whole array of <code>t</code> and expects an array for the predicted <code>u</code> out. This choice of <code>m</code> is based on the assumption that our function is of the form <code>p1*sin(p2*t)+p3*cos(p4*t)</code>. We want to find the <code>p</code> to match our data. Let&#39;s start with the guess of every <code>p</code> being zero, that is <code>p=ones(4)</code>. Then we would fit this curve using:</p><pre><code class="language-julia hljs">using Optim
A = Curvefit(u, t, m, ones(4), LBFGS())
plot(A)</code></pre><img src="f4af3034.svg" alt="Example block output"/><p>We can check what the fitted parameters are via:</p><pre><code class="language-julia hljs">A.pmin</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
  1.00251731850411
  1.0396588440319725
 -0.13178842465264956
  1.0670107400675999</code></pre><p>Notice that it essentially made <code>p3=0</code> with <code>p1=p2=1</code>, meaning it approximately found <code>sin(t)</code>! But note that the ability to fit is dependent on the initial parameters. For example, with <code>p=zeros(4)</code> as the initial parameters, the fit is not good:</p><pre><code class="language-julia hljs">A = Curvefit(u, t, m, zeros(4), LBFGS())
plot(A)</code></pre><img src="fe445386.svg" alt="Example block output"/><p>And the parameters show the issue:</p><pre><code class="language-julia hljs">A.pmin</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 0.0
 0.0
 0.042632088464589324
 0.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« DataInterpolations.jl</a><a class="docs-footer-nextpage" href="../interface/">Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 23 July 2024 12:38">Tuesday 23 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
